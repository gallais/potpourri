\section{Correct by Construction}

\begin{frame}[fragile]{Workflow: Write, Test, Fix loop}

\begin{lstlisting}{Fortran}
  10 WRITE CODE
  20 DO FORMALISATION
  30 IF (CONTAINS BUG) THEN
  40   GOTO 10
  50 END IF
\end{lstlisting}

\end{frame}

\begin{frame}{Idris 2}
  \begin{itemize}
    \item Functional
    \item Typed
    \item First class types
    \item Resource-aware
    \item Compiled to ChezScheme
  \end{itemize}
\end{frame}


\begin{frame}{Idea}
  Define a Domain Specific Language internalising
  Separation logic ideas

  \begin{itemize}
    \item Linearity (ab)used to ensure global uniqueness
    \item Ownership proofs instead of raw pointers
    \item Relying on erasure to distinguish specification vs. runtime
  \end{itemize}

\end{frame}

\begin{frame}{Ownership Type}


  $$\mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs}$$

  \ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{owned}

\end{frame}

\newcommand{\listappend}{\mathop{+\!\!\!+}}

\begin{frame}{Read}
  $$\left\lbrace
    \uncover<2->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs}\\
      \uncover<3->{\sepconj & 0 \le \mathit{idx} < | \mathit{vs} |}
    \end{array}}
    \right\rbrace$$
  $$v = \mathtt{getBits8}(\mathit{idx});$$
  $$\left\lbrace
    \uncover<4->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs}\\
      \sepconj & v = \mathit{vs}[\mathit{idx}]
    \end{array}}
    \right\rbrace$$

  \uncover<5->{\ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{read}}
\end{frame}

\begin{frame}{Write}
  $$\left\lbrace
    \uncover<2->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs}\\
      \uncover<3->{\sepconj & 0 \le \mathit{idx} < | \mathit{vs} |}
    \end{array}}
    \right\rbrace$$
  $$\mathtt{setBits8}(\mathit{idx}, \mathit{val});$$
  $$\left\lbrace
    \uncover<4->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs}[\mathit{idx} := \mathit{val}]\\
    \end{array}}
    \right\rbrace$$

  \uncover<5->{\ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{write}}
\end{frame}

\begin{frame}{Split}
  $$\left\lbrace
    \uncover<2->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs} \listappend{} \mathit{ws}\\
      \uncover<3->{\sepconj & | \mathit{vs} | = \mathit{m}}
    \end{array}}
    \right\rbrace$$
  $$\mathtt{splitAt}(\mathit{m});$$
  $$\left\lbrace
    \uncover<4->{\begin{array}{cl}
        & \mathit{region}[\mathit{start}, \mathit{start} + \mathit{m}] \mapsto \mathit{vs}\\
        \sepconj & \mathit{region}[\mathit{start} + \mathit{m}, \mathit{end}] \mapsto \mathit{ws}
    \end{array}}
    \right\rbrace$$

    \uncover<5->{\ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{split}}
\end{frame}

\begin{frame}{Combine}
  $$\left\lbrace
    \uncover<2->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{middle}] \mapsto \mathit{vs}\\
      \sepconj & \uncover<3->{\mathit{region}[\mathit{middle}, \mathit{end}] \mapsto \mathit{ws}}
    \end{array}}
    \right\rbrace$$
  $$\mathtt{combine}();$$
  $$\left\lbrace
    \uncover<4->{\begin{array}{cl}
      & \mathit{region}[\mathit{start}, \mathit{end}] \mapsto \mathit{vs} \mathop{+\!\!\!+} \mathit{ws}
    \end{array}}
    \right\rbrace$$

    \uncover<5->{\ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{combine}}
\end{frame}


\begin{frame}{Sequential Map}
  \ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{mapType}
  \ExecuteMetaData[Data/Buffer/Indexed.idr.tex]{loop}
\end{frame}


\begin{frame}{Parallel Map}
\end{frame}
