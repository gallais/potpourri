\section{Thinnings, cooked two ways}\label{sec:codebruijn}

We experienced a major limitation of compilation of inductive families
during our ongoing development of
\typos~\cite{MANUAL:talk/types/Allais22}, a domain specific language
to define concurrent typecheckers and elaborators.
%
Core to this project is the definition of actors manipulating a generic notion
of syntax with binding.
%
Internally the terms of this syntax with binding are based on a co-de Bruijn
representation (an encoding we will explain below) which relies heavily on
thinnings.
%
A thinning (also known as an Order Preserving
Embedding~\cite{MANUAL:phd/nott/Chapman09})
between a source and a target scope is an order preserving affine injection
of the smaller scope into the larger one.
%
They are usually represented using an inductive family.
%
The omnipresence of thinnings in the co-de Bruijn representation makes their
runtime representation a performance critical matter.

Let us first remind the reader of the structure of abstract syntax trees in a
named, a de Bruijn, and a co-de Bruijn representation. We will then discuss two
representations of thinnings: a safe and convenient one as an inductive family,
and an unsafe but efficient encoding as a pair of arbitrary precision integers.

\subsection{Named, de Bruijn, and co-de Bruijn syntaxes}

In this section we will use the $S$ combinator as a running example and represent
terms using a syntax tree whose constructor nodes are circles and variable nodes
are squares.
%
To depict the $S$ combinator we will only need $\lambda{}$-abstraction and
application (rendered \$) nodes. A constructor's arguments become its children
in the tree.
%
The tree is layed out left-to-right and a constructor's arguments are displayed
top-to-bottom.

\paragraph{Named syntax}
The first representation is using explicit names. Each binder has an associated
name and each variable node carries a name. A variable refers to the closest englobing
binder which happens to be using the same name.

\ExecuteMetaData[ast.tex]{named}

To check whether two terms are structurally equivalent (\emph{$\alpha$-equivalence})
potentially requires renaming bound names.
%
In order to have a simple and cheap $\alpha$-equivalence check we can instead opt
for a nameless representation.

\paragraph{De Bruijn syntax}
An abstract syntax tree based on de Bruijn indices~\cite{MANUAL:journals/math/debruijn72}
replaces names with natural numbers counting the number of binders separating a variable
from its binding site.
%
You can see in the following graphical depiction of the $S$ combinator that
$\lambda$-abstractions do not carry a name anymore and that variables are simply pointing
to the binder that introduced them. We have left the squares empty but in practice
the various coloured arrows would be represented by a natural number.
%
For instance the {\color{magenta}magenta} one corresponds to $1$ because you need
to ignore one $\lambda{}$-abstraction (the {\color{orange}orange} one) on your way
towards the root of the tree before your reach the corresponding magenta binder.

\ExecuteMetaData[ast.tex]{debruijn}

To check whether a subterm does not mention a given set of variables
(a \emph{thickening} test, the opposite of a \emph{thinning} which extends the
current scope with unused variables), you need to traverse the term in its entirety.
%
In order to have a simple and cheap thickening test we can ensure that each subterms
knows precisely what its exact scope (i.e. its \emph{support}) is and how it embeds
in its parent's.

\paragraph{Co-de Bruijn syntax}
In a co-de Bruijn
representation~\cite{DBLP:journals/corr/abs-1807-04085} each subterm
selects exactly the variables that stay in scope for that term,
and so a variable constructor ultimately refers to the only variable still
in scope by the time it is reached.
%
This representation ensures that we know precisely what the scope of a given term
currently is.

In the following graphical rendering, we represent thinnings as lists of full
($\bullet$) or empty ($\circ$) discs depending on whether the corresponding
variable is either kept or discarded.
For instance the thinning represented by
$\color{blue}{\circ}\color{magenta}{\bullet}\color{orange}{\bullet}$
throws the {\color{blue}blue} variable away, and keeps both the
{\color{magenta}magenta} and {\color{orange}orange} ones.

\ExecuteMetaData[ast.tex]{codebruijn}

We can see that in such a representation, each node in the tree stores one
thinning per subterm. This will not be tractable unless we have an efficient
representation of thinnings.

%% We can recover terms living in arbitrary scopes by pairing a co-de Bruijn term
%% with a thinning embedding its tight support into the given englobing scope.
%% \todo{defined CdB}

\subsection{The Performance Challenges of co-de Bruijn}~\label{sec:thinningsintypos}

Having a precise handle on each term's support makes operations like thinning,
substitution, and unification more efficient.
%
An arbitrary term is represented by the pairing of a term in co-de Bruijn syntax
with a thinning from its support into the wider scope.
%
As a consequence we do not need to traverse a term to embed it in a wider context.
We can simply compose thinnings.
%
Similarly, we can easily detect when a substitution's domain does not contain any
of the variables present in the term, and the action of the substitution is therefore
the identity.
%
Finally we can perform cheap thickening tests when trying to solve a metavariable with
a term that arose in a wider scope.

For all of these reasons we have, as we mentioned earlier, opted for a co-de Bruijn
representation in the implementation of \typos~\cite{MANUAL:talk/types/Allais22}.
%
And so it is crucial for performance that we have a compact representation of thinnings.
%
We first carefully worked out the trickier parts of the implementation in Agda before
porting the resulting code to Haskell.
%
This process highlighted a glaring gap between on the one hand the experiments done
using a strongly typed inductive representation of thinnings and on the other hand
their more efficient but unsafe encoding in Haskell.

\subsubsection{Thinnings in \typos}

The Agda-based experiments use inductive families that make the key invariants
explicit which helps tracking complex constraints and catches design flaws at
typechecking time.
%
The indices guarantee that we always transform the thinnings appropriately when
we add or remove bound variables. In \idris{}, the inductive family representation
of thinnings would be written:

\ExecuteMetaData[Thinnings.idr.tex]{thinning}
%
The \IdrisType{Thinning} family is indexed by two scopes (represented as snoclists
i.e. lists that are extended from the right, just like contexts in inference rules):
\IdrisBound{sx} the tighter scope and \IdrisBound{sy} the wider one.
%
The \IdrisData{Done} constructor corresponds to a thinning from the empty scope to
itself (\IdrisData{[<]} is \idris{} syntactic sugar for the empty snoclist),
and \IdrisData{Keep} and \IdrisData{Drop} respectively extend a given thinning
by keeping or dropping the most local variable (\IdrisData{:<} is the `snoc'
constructor, a sort of flipped `cons').
%
The `name' (\IdrisBound{x} of type \IdrisBound{a}) is marked with the quantity
\IdrisKeyword{0} to ensure it is erased at compile time (cf. \cref{sec:quantitativeTT}).
%
At runtime this representation is therefore essentially a linked list of booleans.

The Haskell implementation represents a thinning as a pair of integers: one encoding
the bit pattern corresponding to the list of booleans mentioned above, and the other
specifying the number of relevant bits in this encoding i.e. the size of the outer scope.
%
Basic operations on thinnings are implemented by explicitly manipulating individual bits.
%
It is not indexed and thus all the invariant tracking has to be done by hand.
This has led to numerous and hard to diagnose bugs.

\subsubsection{Thinnings in \idris}

\idris{} is a bootstrapped language whose core datatype is currently based on
a well-scoped de Bruijn representation.
%
This precise indexing of terms by their scope helped entirely eliminate a whole
class of bugs that would plague Idris 1's unification machinery.

If we were to switch to a co-de Bruijn representation for our core language we
would want, and should be able, to have the best of both worlds:
a safe \emph{and} efficient representation!

Luckily \idris{} implements Quantitative Type Theory (QTT) which gives us a
lot of control over what is to be runtime relevant and what is to be erased
during compilation.
%
This should allow us to insist on having a high-level interface that resembles
an inductive family while ensuring that everything but a pair of integers is erased
at compile time.
%
We will exploit the key features of QTT presented in \cref{sec:quantitativeTT}
to solve this conundrum.
