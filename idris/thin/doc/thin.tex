\documentclass{article}

\usepackage{catchfilebetweentags}
\input{robust-catch}

\usepackage{idris2}

\usepackage{minted}
\usepackage{cleveref}

\usepackage{todonotes}
\setuptodonotes{inline}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric}

\newcommand{\typos}{TypOS}
\newcommand{\idris}{Idris 2}
\newcommand{\coq}{Coq}
\newcommand{\agda}{Agda}

\bibliographystyle{alpha}

\overfullrule=1mm

\begin{document}

\title{Builtin Types viewed as Inductive Families \\
{\large Efficiently Representing Thinnings in \idris, a case study}}
\author{Guillaume Allais}

\maketitle

\begin{abstract}
  Remembering that types give us a way to make sense of unstructured data stored
  in memory, we demonstrate how to use Quantitative Type Theory to define an
  invariant-rich typechecking time data structure that is guaranteed to compile
  to an efficient runtime one.

  Unlike other approaches, the resulting complexity is entirely predictable, we do
  not require both representations to have the same structure, and yet we are able
  to seamlessly program as if we were using the high-level structure.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Dependently typed languages have empowered users to precisely describe their domain
of discourse by using inductive families~\cite{DBLP:journals/fac/Dybjer94}.
%
Programmers can bake crucial invariants directly into their definitions thus refining
both their functions' inputs and outputs.
%
The constrained inputs allow them to only consider the relevant cases during pattern
matching, while the refined outputs guarantee that client code can safely rely on the
invariants being maintained.
%
This programming style is dubbed `correct by construction'.

However relying on inductive families can have a non-negligible runtime cost if
the host language is compiling them na√Øvely. And even state of the art optimisation
passes for dependently typed languages cannot make miracles: if the source code is
not efficient, the executable will not be either.

In \cref{sec:optimisation-example}, we will look at an optimisation example
that highlights both the strengths and the limitations of the current state
of the art when it comes to removing the runtime overheads potentially
incurred by using inductive families.

In \cref{sec:codebruijn} we will then look at an inductive family that we
use in a performance-critical way in the \typos{}
project and whose compilation suffers from said limitations.
%
Our current and unsatisfactory approach is to rely on the safe and convenient
inductive family when experimenting in Agda and then replace it with an unsafe
but vastly more efficient representation in our actual Haskell implementetation.

In \cref{sec:quantitativeTT} we will give a quick introduction to Quantitative
Type Theory, the expressive language that grants programmers the ability
to have both strong invariants and, reliably, a very efficient runtime
representation.

Finally in \cref{sec:efficient}, we will study the actual implementation of
our efficient and invariant-rich solution implemented in \idris{}. We will
also demonstrate that we can recover almost all the conveniences of programming
with inductive families thanks to smart constructors and views.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% imports
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{optimisation}
\input{CdB}
\input{QTT}
\input{efficient}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conclusion}

We have seen that inductive families provide programmers with ways to root out bugs
by enforcing strong invariants. Unfortunately these families can get in the way of
producing performant code despite existing optimisation passes erasing redundant
or runtime irrelevant data.
%
This has led us to take advantage of Quantitative Type Theory in order to design a library
combining the best of both worlds: the strong invariants and ease of use of inductive
families together with the runtime performance of explicit bit manipulations.

\subsection{Related Work}

For historical and ergonomic reasons, idiomatic code in \coq{} tends to center programs
written in a subset of the language quite close to OCaml and then prove properties
about these programs in the runtime irrelevant \texttt{Prop} fragment.
%
This can lead to awkward encodings when the unrefined inputs force the user to consider
cases which ought to be impossible. Common coping strategies involve relaxing the types
to insert a modicum of partiality e.g. returning an option type or taking an additional
input to be used as the default return value.
%
This approach completely misses the point of type-driven development. We benefit a lot
from having as much information as possible available during interactive editing. This
helps tremendously getting the definitions right by ensuring we always maintain vital
invariants thus making invalid states unrepresentable.
%
Thankfully libraries such as Equations~\cite{DBLP:conf/itp/Sozeau10,DBLP:journals/pacmpl/SozeauM19}
can help users write more dependently typed programs, by taking care of the complex
encoding required in \coq{}. A view-based approach similar to ours but using \texttt{Prop}
instead of the zero quantity ought to be possible.

Prior work on erasure~\cite{DBLP:journals/pacmpl/Tejiscak20} has the advantage of
offering a fully automated analysis of the code. The main inconvenient is that users
cannot state explicitly that a piece of data ought to be runtime irrelevant and so
they may end up inadvertently using it which would prevent its erasure.
%
Quantitative Type Theory allows us users to explicitly choose what is and is not
runtime relevant, with the quantity checker keeping us true to our word.
%
This should ensure that the resulting program has a much more predictable complexity.

A somewhat related idea was explored by Brady, McKinna, and Hammond in the context of
circuit design~\cite{DBLP:conf/sfp/BradyMH07}. In their verification work they index
an efficient representation (natural numbers as a list of bits) by its meaning as a
unary natural number. All the operations are correct by construction as witnessed by
the use of their unary counterparts acting as type-level specifications.
%
In the end their algorithms still process the inductive family instead of working
directly with binary numbers. This makes sense in their setting where they construct
circuits and so are explicitly manipulating wires carrying bits.
%
By contrast, in our motivating example we really want to get down to actual (unbounded)
integers rather than linked lists of bits.

\todo{Iris}

\subsection{Limitations and Future Work}

Unfortunately it is only \emph{propositionally} true that
(\IdrisFunction{view} (\IdrisFunction{keep} \IdrisBound{th} \IdrisBound{x}))
computes to (\IdrisData{Keep} \IdrisBound{th} \IdrisBound{x}) (and similarly for
\IdrisFunction{done}/\IdrisData{Done} and \IdrisFunction{drop}/\IdrisData{Drop}).
%
This means that users may need to manually deploy these lemmas when proving the
properties of functions defined by pattern matching on the result of calling the
\IdrisFunction{view} function.
%
This annoyance would disappear if we had the ability to extend \idris{}'s reduction rules
with user-proven equations as suggested by Cockx, Tabareau, and
Winterhalter~\cite{DBLP:journals/pacmpl/CockxTW21}.
\todo{re-read Taming}

Our objectives are twofold: we would like to explore more low-level operations and
extend language support for this style of programming.

The \idris{} standard library gave us access to a pure interface to explicitly
manipulate an integer's bits. There is no such thing yet for interacting with a
read-only array for instance.


\todo{Explain annoying inversion lemmas}

Our library of efficient operations on thinnings currently suffers from having to
implement annoyingly verbose inversion lemmas. This is caused by the fact that
\idris{} will not let you pattern-match on a runtime irrelevant value in a runtime
relevant context. It should however be safe to do so if all but one branches can
be proven to be impossible, or even more generally, if the information thus obtained
only flows into runtime irrelevant arguments.


\bibliography{thin}

\end{document}
