\documentclass{article}

\usepackage{catchfilebetweentags}
\input{robust-catch}

\usepackage{idris2}

\usepackage{minted}

\usepackage{todonotes}
\setuptodonotes{inline}

\newcommand{\typos}{TypOS}
\newcommand{\idris}{Idris 2}
\newcommand{\coq}{Coq}
\newcommand{\agda}{Agda}

\bibliographystyle{alpha}

\begin{document}

\title{Builtin Types viewed as Inductive Families \\
{\large Efficiently Representing Thinnigs in \idris, a case study}}
\author{Guillaume Allais}

\maketitle

\begin{abstract}
  Remembering that types give us a way to make sense of unstructured data stored
  in memory, we demonstrate how to use Quantitative Type Theory to define an
  invariant-rich typechecking time data structure that is guaranteed to compile
  to an efficient runtime one.

  Unlike other approaches, the resulting complexity is entirely predictable, we do
  not require both representations to have the same structure, and yet we are able
  to seamlessly program as if we were using the high-level structure.
\end{abstract}

\section{Introduction}

Dependently typed languages have empowered users to precisely describe their domain
of discourse by using inductive families~\cite{DBLP:journals/fac/Dybjer94}.
%
Programmers can bake crucial invariants directly into their definitions thus refining
both their functions' inputs and outputs.
%
The constrained inputs allow them to only consider the relevant cases during pattern
matching, while the refined outputs guarantee that client code can safely rely on the
invariants being maintained.
%
These programming style is dubbed `correct by construction'.

However relying on inductive families can have a non-negligible runtime cost if
the host language is compiling them naïvely. And even state of the art optimisation
passes for dependently typed languages cannot make miracles: if the source code is
not efficient, the executable will not be either.

\subsection{An Optimisation Example}

The prototypical examples of the naïve compilation of inductive families being
inefficient are probably the types of vectors (\IdrisType{Vect})
and finite numbers (\IdrisType{Fin}).
%
Their interplay is demonstrated by the \IdrisFunction{lookup} function.
Let us study this example and how successive optimisation passes can, in this
instance, get rid of the overhead introduced by using indexed families over
plain data.

A vector is a length-indexed list. The type \IdrisType{Vect} is parameterised
by the type of values it stores and indexed over a natural number corresponding
to its length.
%
More concretely, its \IdrisData{Nil} constructor builds an empty vector of size
\IdrisData{0}, and its \IdrisData{(::)} (pronounced `cons') constructor combines a
value of type \IdrisBound{a} (the head) and a subvector of size \IdrisBound{n}
(the tail) to build a vector of size (\IdrisData{1} \IdrisFunction{+} \IdrisBound{n}).

\ExecuteMetaData[Lookup.idr.tex]{vect}

The size \IdrisBound{n} is not explicitly bound in the type of \IdrisData{(::)}.
In \idris{}, this means that it is automatically generalised over in a prenex
manner reminiscent of the handling of free type variables in languages in the
ML family.
%
This makes it an implicit argument of the constructor. Consequently, given that
\IdrisType{Nat} is a type of \emph{unary} natural numbers, a naïve runtime
representation of a {(\IdrisType{Vect} \IdrisBound{n} \IdrisBound{a})} would
have a size quadratic in \IdrisBound{n}.

A finite number is a number known to be strictly smaller than a given natural
number. The type \IdrisType{Fin} is indexed by said bound.
%
Its \IdrisData{Z} constructor models \IdrisData{0} and is bound by any
non-zero bound, and its \IdrisData{S} constructor takes a number bound by
\IdrisBound{n} and returns its successor, bound by
(\IdrisData{1} \IdrisFunction{+} \IdrisBound{n}).
%
A naïve compilation would here also lead to a runtime representation suffering
from a quadratic blowup.

\ExecuteMetaData[Lookup.idr.tex]{fin}

This leads us to the definition of the \IdrisFunction{lookup} function.
%
Provided a vector of size \IdrisBound{n} and a finite number \IdrisBound{k} bound
by this same \IdrisBound{n}, we can define a \emph{total} function looking up the
value stored at position \IdrisBound{k} in the vector.
%
It is guaranteed to return a value.
%
Note that we do not need to consider the case of the empty vector in the pattern
matching clauses as all of the return types of the \IdrisType{Fin} constructors force
the index to be non-zero and, because the vector and the finite number talk about the
same \IdrisBound{n}, having an empty vector would automatically imply having a value
of type (\IdrisType{Fin} \IdrisData{0}) which is self-evidently impossible.

\ExecuteMetaData[Lookup.idr.tex]{vectlookup}

Thanks to our indexed family, we have gained the ability to define a function that cannot
possibly fail, as well as the ability to only talk about the pattern matching clauses
that make sense.
This seemed to be at the cost of efficiency but luckily for us there has already been
extensive work on erasure to automatically detect redundant
data~\cite{DBLP:conf/types/BradyMM03} or data that will not be used at
runtime~\cite{DBLP:journals/pacmpl/Tejiscak20}.

A Brady-style analysis~\cite{DBLP:conf/types/BradyMM03}
can solve the quadratic blowup highlighted above by observing
that the natural number a vector is indexed by is entirely determined by the spine of
the vector. In particular, the length of the predecessor does not need to be stored
as part of the constructor: it can be reconstructed as the predecessor of the length
of the overall vector. As a consequence, a vector can be adequately represented at
runtime by a pair of a natural number and a list. Similarly the bounded number can be
adequately represented by a pair of natural numbers. Putting all of this together and
remembering that the vector and the finite number share the same \IdrisBound{n},
\IdrisFunction{lookup} can be compiled to a function taking two natural numbers and a list.
In \idris{} we would write the optimised \IdrisFunction{lookup} as follows (we use the
\IdrisKeyword{partial} keyword because this transformed version is not total at that type).

\ExecuteMetaData[Lookup.idr.tex]{erasedvectlookup}

We can see in the second clause that the recursive call is performed on the tail of
the list (formerly vector) and so the first argument to \IdrisFunction{lookup}
corresponding to the vector's size is decreased by one. The invariant, despite not
being explicit anymore, is maintained.

A Tejiščák-style analysis~\cite{DBLP:journals/pacmpl/Tejiscak20} can additionally
notice that the lookup function never makes
use of the bound's value and drop it entirely. This leads to the lookup function on
vectors being compiled to its partial-looking counterpart acting on lists.

\ExecuteMetaData[Lookup.idr.tex]{finallookup}

Even though this is in our opinion a pretty compelling example of erasing away the
apparent complexity introduced by inductive families, we need to stay
realistic.
%
For this approach to work, the compiler needs to be able to automatically map the
indexed family to a simpler datatype that can then be extracted to the target language.
%
It is particularly important here to observe that if the types have been simplified,
they still have very much the same structure. We cannot expect much better than that.

\subsection{No Magic Solution}

Even if we are able to obtain a more compact representation of the inductive
family at runtime through enough erasure, this does not guarantee runtime efficiency.
As the \coq{} manual~\cite{Coq:manual} reminds its users, extraction does not magically
optimises away a user-defined quadratic multiplication algorithm when extracting unary
natural numbers to an efficient machine representation.
%
In a pragmatic move, \coq{}, \agda{}, and \idris{} all have ad-hoc rules to replace
convenient but inefficiently implemented numeric functions with asymptotically faster
counterparts in the target language.

However this is not scalable: if we may be willing to extend our trusted core to a
high quality library for unbounded integers, we cannot possibly contemplate replacing
our code only proven correct thanks to complex invariants with a wildly different
untrusted counterpart purely for efficiency reasons.

In this paper we use Quantitative Type
Theory~\cite{DBLP:conf/birthday/McBride16,DBLP:conf/lics/Atkey18}
as implemented in \idris{}~\cite{DBLP:conf/ecoop/Brady21} to bridge the gap between
an invariant-rich but inefficient representation based on an inductive family and
an unsafe but efficient implementation using low-level primitives.
%
Inductive families allow us to \emph{view}~\cite{DBLP:journals/jfp/McBrideM04} the
runtime relevant information encoded in the low-level and efficient representation
as an information-rich compile time data structure. Moreover the quantity annotations
guarantee that this additional information will be erased away during compilation.

\section{Quantitative Type Theory}

Quantitative Type Theory is a type theory enriched with a semiring of quantities
classifying the ways in which values may be used.

\subsection{Quantities}

A value may be \emph{runtime irrelevant}, \emph{linear}, or \emph{unrestricted}.

\emph{Runtime irrelevant} values (\IdrisKeyword{0} quantity) cannot possibly influence
control flow.
%
This forces the language to impose strong restrictions on pattern-matching over these
values.
%
Typical examples are types like the \IdrisBound{a} parameter in (\IdrisType{List} \IdrisBound{a}),
or indices like the natural number \IdrisBound{n} in
(\IdrisType{Vect} \IdrisBound{n} \IdrisBound{a}).
%
These are guaranteed to be erased at compile time. The advantage over a Tejiščák-style
analysis is that users can state their intent that an argument ought to be runtime
irrelevant and the language will insist that it needs to be convinced it indeed is.

\emph{Linear} values (\IdrisKeyword{1} quantity) have to be used exactly once.
%
Typical examples include the \IdrisData{\%World} token used by \idris{} to implement the
\IdrisType{IO} monad à la Haskell, or file handles that cannot be discarded without explicitly
closing the file.
%
At runtime these values can be updated destructively. We will not use linearity in this study.

Last, \emph{unrestricted} values (denoted by no quantity annotation) can flow into any
position, be duplicated or thrown away. They are the usual values of functional programming.

\subsection{Examples}

The most basic of examples is the identity function.

\ExecuteMetaData[QuantitativeTT.idr.tex]{identity}

Its type starts with a binder using curly braces. This means it introduces an implicit
variable that does not need to be filled in by the user at call sites and will be
reconstructed by unification. The variable it introduces is named \IdrisBound{a} and
has type \IdrisType{Type}. It has the \IdrisKeyword{0} quantity annotation which means
that this argument is runtime irrelevant and so will be erased during compilation.

The second binder is using parentheses. It introduces an explicit variable whose name
is \IdrisBound{x} and whose type is the type \IdrisBound{a} that was just bound. It has
no quantity annotation which means it will be an unrestricted variable.

Finally the return type is the type \IdrisBound{a} bound earlier. This is, as expected,
a polymorphic function from \IdrisBound{a} to \IdrisBound{a}. It is implemented using
a single clause that binds \IdrisBound{x} on the left-hand side and immediately returns
it on the right-hand side.


If we were to try to annotate the binder for \IdrisBound{x} with a \IdrisKeyword{0}
quantity to make it runtime irrelevant then \idris{} would
rightfully reject the definition.
%
The following \IdrisKeyword{failing} block shows part of the error message complaining
that \IdrisBound{x} cannot be used at an unrestricted quantity on the right-hand side.

\ExecuteMetaData[QuantitativeTT.idr.tex]{invalididentity}

%\ExecuteMetaData[QuantitativeTT.idr.tex]{vect}

\section{Co-de Bruijn representation, cooked two ways}

Using a de Bruijn representation~\cite{MANUAL:journals/math/debruijn72} each variable
points to the binder that introduced it. In a co-de Bruijn
representation~\cite{DBLP:journals/corr/abs-1807-04085} each subterm
selects exactly the variables that stay in scope for that term,
and so a variable constructor ultimately refers to the only variable still
in scope by the time it is reached.
%
This representation ensures that we know precisely what the scope of a given term
currently is.

We can recover terms living in arbitrary scopes by pairing a co-de Bruijn term
with a thinning embedding its tight support into the given englobing scope.
\todo{defined CdB}

\todo{application e.g. shrinking}

In order to efficiently represent and traverse terms in co-de Bruijn representation,
we need a compact encoding of thinnings and a cheap composition operator.
\todo{example: opening an application node}

The implementation of \typos~\cite{MANUAL:talk/types/Allais22} uses a co-de Bruijn
representation internally. \todo{explain why}
%
The developpement of the \typos{} language highlights a glaring gap between on the
one hand the experiments done in Agda and on the other the actual implementation
in Haskell.
%
The Agda-based experiments use inductive families that make the key invariants explicit
which helps tracking complex constraints and catches design flaws. The indices guarantee
that we always transform the thinnings appropriately when we add or remove bound variables.
%
The Haskell implementation represents a thinning as a pair of integers and resorts to
explicitly manipulating individual bits. It is not indexed and thus all the invariant
tracking has to be done by hand. This has led to numerous and hard to diagnose bugs.

\idris{} is a bootstrapped language. If we were to use such a co-deBruijn representation
of terms as a replacement for \idris{}'s current core language we would want, and should
be able, to have the best of both worlds: a safe and efficient representation!

\section{An Efficient Invariant-Rich Representation}

We can combine both approaches by defining a record parameterised by a source
(\IdrisBound{sx}) and target (\IdrisBound{sy}) scopes corresponding to the two
ends of the thinnings, just like we would for the inductive family. This record
packs two numbers and a runtime irrelevant proof.
%
Firstly, we have a natural number called \IdrisFunction{bigEnd} corresponding
to the size of the big end of the thinning (\IdrisBound{sy}),
%
Secondly, we have an integer called \IdrisFunction{encoding} corresponding to
the thinning represented as a bit vector stating, for each variable, whether
it is kept or dropped. We only care about the integer's \IdrisFunction{bigEnd}
first bits and assume the rest is set to 0.
%
Thirdly, we have a runtime irrelevant proof \IdrisFunction{thinning} that
\IdrisFunction{encoding} is indeed a valid encoding of size \IdrisFunction{bigEnd}
of a thinning from \IdrisBound{sx} to \IdrisBound{sy}. We will explore the
definition of the relation \IdrisType{Thinning} in a later section.

\ExecuteMetaData[Thin.idr.tex]{thin}

The first sign that this definition is adequate is our ability to construct
any valid thinning. We demonstrate it is the case by introducing functions
that act as smart constructor analogues for the inductive family's data
constructors.

\subsection{Smart Constructors for \IdrisType{Th}}

The first and simplest one is \IdrisFunction{done}, a function that packs a pair of
\IdrisData{0} (the size of the big end, and the empty encoding) together with a proof
that it is an adequate encoding of the thinning from the empty scope to itself.

\ExecuteMetaData[Thin.idr.tex]{done}

The \IdrisFunction{keep} smart constructor demonstrates that from a thinning from
\IdrisBound{sx} to \IdrisBound{sy} and a runtime irrelevant variable \IdrisBound{x}
we can compute a thinning from the extended source scope
(\IdrisBound{sx} \IdrisData{:<} \IdrisBound{x}) to the target scope
(\IdrisBound{sy} \IdrisData{:<} \IdrisBound{x}) where \IdrisBound{x} was kept.

\ExecuteMetaData[Thin.idr.tex]{keep}

Similarly the \IdrisFunction{drop} function demonstrates that we can compute a
thinning getting rid of the variable \IdrisBound{x} freshly added to the target
scope.

\ExecuteMetaData[Thin.idr.tex]{drop}

We can already deploy these smart constructors to implement functions producing
thinnings. We use \IdrisFunction{which} as our example. It is a filter-like
function that returns the elements that satisfy a boolean predicate together with
a proof that there is a thinning embedding them back into the input snoclist.
%
If the input snoclist is empty then the output shall also be, and
\IdrisFunction{done} builds a thinning from \IdrisData{[<]} to itself.
%
If it is not empty we can perform a recursive call on the tail of the snoclist
and then depending on whether the predicates holds true of the head we can either
\IdrisFunction{keep} or \IdrisFunction{drop} it.

\ExecuteMetaData[Thin.idr.tex]{which}

We are now equipped with these smart constructors that allow us to seamlessly
build thinnings.
%
To recover the full expressive power of the inductive family, we also need to
be able to take these thinnings apart. This is the role played by the following
view~\cite{DBLP:journals/jfp/McBrideM04}.

\subsection{A View for \IdrisType{Th}}

The \IdrisType{View} family is a sum type indexed by a thinning. It has one
data constructor associated to each smart constructor and storing its arguments.

\ExecuteMetaData[Thin.idr.tex]{view}

The accompanying \IdrisFunction{view} function witnesses the fact that any
thinning arises as one of these three cases.

\ExecuteMetaData[Thin.idr.tex]{viewtotal}

We can readily use this function to implement pattern matching functions taking
a thinning apart. We can for instance define \IdrisFunction{kept}, the function
that counts the number of \IdrisFunction{keep} smart constructors used when
manufacturing the input thinning and returns a proof that this is exactly the
length of the source scope \IdrisBound{sx}.

\ExecuteMetaData[Thin.idr.tex]{kept}

We proceed by calling the \IdrisFunction{view} function on the input thinning
which immediately tells us that we only have three cases to consider.
%
The \IdrisData{Done} case is easily handled because the branche's refined
types inform us that both \IdrisBound{sx} and \IdrisBound{sy} are the
empty snoclist \IdrisData{[<]} whose length is evidently \IdrisData{0}.
%
In the \IdrisData{Keep} branch we learn that \IdrisBound{sx} has the shape
(\IdrisBound{\KatlaUnderscore} \IdrisData{:<} \IdrisBound{x}) and so we must return the
successor of whatever the result of the recursive call gives us.
%
Finally in the \IdrisData{Drop} case, \IdrisBound{sx} is untouched and so a
simple recursive call suffices.
%
Note that the function is correctly detected as total because the target scope
\IdrisBound{sy} is indeed getting structurally smaller at every single recursive
call.
%
It is runtime irrelevant but it can still be successfully used as a termination
measure by the compiler.

\subsection{The \IdrisType{Thinning} Relation}

\ExecuteMetaData[Thin/Internal.idr.tex]{thinning}

\subsection{Choose Your Own Abstraction Level}

Access to both the high-level \IdrisType{View} and the internal \IdrisType{Thinning}
representation means that programmers can pick the level of abstraction at which they
want to work.
%
They may need to explicitly manipulate bits to implement key operators that are used
in performance-critical paths but can stay at the highest level for more negligible
operations, or proofs.

\todo{Insert example e.g. meet and its proof!}

\subsection{Compiled Code}

The following code block shows the javascript code that is produced when compiling the
\IdrisFunction{view} function.
%
The only modifications we have performed are manually inlining a function
corresponding to a \IdrisKeyword{case} block, renaming variables and projections
to match the source code, and adding comments.

\begin{minted}{javascript}
function view($th) {
  switch($th.bigEnd) {
  // empty thinning, use Done
  case 0n: return {tag: 0};
  default: {
    // bigEnd is (S predBE)
    const $predBE = ($th.bigEnd-1n);
    // Test whether the bit at index 0 of encoding is non-zero by
    // using 1n as a bit mask
    // and checking whether the result is not equal to 0
    const $bitTest = choose(notEq($th.encoding&1n, 0n));
    switch($bitTest.tag) {
      case 0: { // The test was true, use Keep
        const $tail = $th.encoding>>1n;
        return {tag: 1, val: {bigEnd: $predBE, encoding: $tail}}; }
      case 1: { // The test was false, use Drop
        const $tail = $th.encoding>>1n;
        return {tag: 2, val: {bigEnd: $predBE, encoding: $tail}}; }
}}}}
\end{minted}

Readers can see that the compilation process has erased all of the indices
and the proofs
showing that the invariant tying the efficient runtime representation to the
high-level specification is maintained.
%
A thinning is represented at runtime by a javascript object with two properties
corresponding to \IdrisType{Th}'s runtime relevant fields. Both are storing a
javascript \texttt{bigInt} (one corresponding to the \IdrisType{Nat}, the other
to the \IdrisType{Integer}).
%
For instance the thinning [01101] would be at runtime
\mintinline{javascript}{{ bigEnd: 5n, encoding: 13n }}.
%

By running \IdrisFunction{view} on this [01101] thinning, we would get
back (\IdrisData{Keep} [0110]), that is to say
\mintinline{javascript}{{ tag: 1, val: { bigEnd: 4n, encoding: 6n } }}.

\section{Conclusion}

We have seen that inductive families provide programmers with ways to root out bugs
by enforcing strong invariants. Unfortunately these families can get in the way of
producing performant code despite existing optimisation passes erasing redundant
or runtime irrelevant data.
%
This has led us to take advantage of Quantitative Type Theory in order to design a library
combining the best of both worlds: the strong invariants and ease of use of inductive
families together with the runtime performance of explicit bit manipulations.

\subsection{Related Work}

For historical and ergonomic reasons, idiomatic code in \coq{} tends to center programs
written in a subset of the language quite close to OCaml and then prove properties
about these programs in the runtime irrelevant \texttt{Prop} fragment.
%
This can lead to awkward encodings when the unrefined inputs force the user to consider
cases which ought to be impossible. Common coping strategies involve relaxing the types
to insert a modicum of partiality e.g. returning an option type or taking an additional
input to be used as the default return value.
%
This approach completely misses the point of type-driven development. We benefit a lot
from having as much information as possible available during interactive editing. This
helps tremendously getting the definitions right by ensuring we always maintain vital
invariants thus making invalid states unrepresentable.
%
Thankfully libraries such as Equations~\cite{DBLP:conf/itp/Sozeau10,DBLP:journals/pacmpl/SozeauM19}
can help users write more dependently typed programs, by taking care of the complex
encoding required in \coq{}. A view-based approach similar to ours but using \texttt{Prop}
instead of the zero quantity ought to be possible.

Prior work on erasure~\cite{DBLP:journals/pacmpl/Tejiscak20} has the advantage of
offering a fully automated analysis of the code. The main inconvenient is that users
cannot state explicitly that a piece of data ought to be runtime irrelevant and so
they may end up inadvertently using it which would prevent its erasure.
%
Quantitative Type Theory allows us users to explicitly choose what is and is not
runtime relevant, with the quantity checker keeping us true to our word.
%
This should ensure that the resulting program has a much more predictable complexity.

A somewhat related idea was explored by Brady, McKinna, and Hammond in the context of
circuit design~\cite{DBLP:conf/sfp/BradyMH07}. In their verification work they index
an efficient representation (natural numbers as a list of bits) by its meaning as a
unary natural number. All the operations are correct by construction as witnessed by
the use of their unary counterparts acting as type-level specifications.
%
In the end their algorithms still process the inductive family instead of working
directly with binary numbers. This makes sense in their setting where they construct
circuits and so are explicitly manipulating wires carrying bits.
%
By contrast, in our motivating example we really want to get down to actual (unbounded)
integers rather than linked lists of bits.

\todo{Iris}

\subsection{Limitations and Future Work}

Unfortunately it is only \emph{propositionally} true that
(\IdrisFunction{view} (\IdrisFunction{keep} \IdrisBound{th} \IdrisBound{x}))
computes to (\IdrisData{Keep} \IdrisBound{th} \IdrisBound{x}) (and similarly for
\IdrisFunction{done}/\IdrisData{Done} and \IdrisFunction{drop}/\IdrisData{Drop}).
%
This means that users may need to manually deploy these lemmas when proving the
properties of functions defined by pattern matching on the result of calling the
\IdrisFunction{view} function.
%
This annoyance would disappear if we had the ability to extend \idris{}'s reduction rules
with user-proven equations as suggested by Cockx, Tabareau, and
Winterhalter~\cite{DBLP:journals/pacmpl/CockxTW21}.
\todo{re-read Taming}

Our objectives are twofold: we would like to explore more low-level operations and
extend language support for this style of programming.

The \idris{} standard library gave us access to a pure interface to explicitly
manipulate an integer's bits. There is no such thing yet for interacting with a
read-only array for instance.


\todo{Explain annoying inversion lemmas}

Our library of efficient operations on thinnings currently suffers from having to
implement annoyingly verbose inversion lemmas. This is caused by the fact that
\idris{} will not let you pattern-match on a runtime irrelevant value in a runtime
relevant context. It should however be safe to do so if all but one branches can
be proven to be impossible, or even more generally, if the information thus obtained
only flows into runtime irrelevant arguments.


\bibliography{thin}

\end{document}
