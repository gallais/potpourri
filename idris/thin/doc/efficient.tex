
\section{An Efficient Invariant-Rich Representation}\label{sec:efficient}

We can combine both approaches by defining a record parameterised by a source
(\IdrisBound{sx}) and target (\IdrisBound{sy}) scopes corresponding to the two
ends of the thinnings, just like we would for the inductive family. This record
packs two numbers and a runtime irrelevant proof.

Firstly, we have a natural number called \IdrisFunction{bigEnd} corresponding
to the size of the big end of the thinning (\IdrisBound{sy}).
%
We are happy to use a (unary) natural number here because we know that \idris{}
will compile to an unbounded integer.

Secondly, we have an integer called \IdrisFunction{encoding} corresponding to
the thinning represented as a bit vector stating, for each variable, whether
it is kept or dropped. We only care about the integer's \IdrisFunction{bigEnd}
first bits and assume the rest is set to 0.

Thirdly, we have a runtime irrelevant proof \IdrisFunction{thinning} that
\IdrisFunction{encoding} is indeed a valid encoding of size \IdrisFunction{bigEnd}
of a thinning from \IdrisBound{sx} to \IdrisBound{sy}. We will explore the
definition of the relation \IdrisType{Thinning} later on
in \cref{sec:thininginternal}.

\ExecuteMetaData[Thin.idr.tex]{thin}

The first sign that this definition is adequate is our ability to construct
any valid thinning. We demonstrate it is the case by introducing functions
that act as smart constructor analogues for the inductive family's data
constructors.

\subsection{Smart Constructors for \IdrisType{Th}}

The first and simplest one is \IdrisFunction{done}, a function that packs a pair of
\IdrisData{0} (the size of the big end, and the empty encoding) together with a proof
that it is an adequate encoding of the thinning from the empty scope to itself.

\ExecuteMetaData[Thin.idr.tex]{done}

The \IdrisFunction{keep} smart constructor demonstrates that from a thinning from
\IdrisBound{sx} to \IdrisBound{sy} and a runtime irrelevant variable \IdrisBound{x}
we can compute a thinning from the extended source scope
(\IdrisBound{sx} \IdrisData{:<} \IdrisBound{x}) to the target scope
(\IdrisBound{sy} \IdrisData{:<} \IdrisBound{x}) where \IdrisBound{x} was kept.

\ExecuteMetaData[Thin.idr.tex]{keep}

Similarly the \IdrisFunction{drop} function demonstrates that we can compute a
thinning getting rid of the variable \IdrisBound{x} freshly added to the target
scope.

\ExecuteMetaData[Thin.idr.tex]{drop}

We can already deploy these smart constructors to implement functions producing
thinnings. We use \IdrisFunction{which} as our example. It is a filter-like
function that returns the elements that satisfy a boolean predicate together with
a proof that there is a thinning embedding them back into the input snoclist.
%
If the input snoclist is empty then the output shall also be, and
\IdrisFunction{done} builds a thinning from \IdrisData{[<]} to itself.
%
If it is not empty we can perform a recursive call on the tail of the snoclist
and then depending on whether the predicates holds true of the head we can either
\IdrisFunction{keep} or \IdrisFunction{drop} it.

\ExecuteMetaData[Thin.idr.tex]{which}

We are now equipped with these smart constructors that allow us to seamlessly
build thinnings.
%
To recover the full expressive power of the inductive family, we also need to
be able to take these thinnings apart. We are now going to tackle this issue.

\subsection{Pattern Matching on \IdrisType{Th}}

A view for a type $T$ is, in the sense of McBride and
McKinna~\cite{DBLP:journals/jfp/McBrideM04}, an inductive family
$V$ indexed by $T$ together with a total function which maps every element $t$ of $T$
to a value of type ($V t$).
%
This simple gadget provides a powerful, user-extensible, generalisation of
pattern-matching.
%
Patterns are defined inductively as either a binding position, a forced term
(i.e. an arbitrary expression that is determined by a constraint arising from
another pattern), or a data constructor fully applied to subpatterns.
%
In contrast, the return indices of an inductive family's constructors can be
arbitrary expressions.

\subsubsection{A simple example of a view}

For instance, it is trivial to check whether a (\IdrisType{List} \IdrisBound{a})
is empty or constructed from a head and a tail.
%
In the first case, we would use the constructor \IdrisData{Nil} which is a valid
pattern according to our above definition.
%
In the seconc case, we would use the constructor \IdrisData{(::)} applied to the
variables \IdrisBound{head} and \IdrisBound{tail} acting as binding sites, thus
forming another valid pattern.
%
But it is impossible to look at the list from its end: the expression
(\IdrisBound{xs} \IdrisFunction{++} \IdrisData{[}\IdrisBound{x}\IdrisData{]})
does not fall in the pattern fragment because it mentions the function (\IdrisFunction{++}).
But we can define a view showing what it means to have this shape.

\ExecuteMetaData[Snoc.idr.tex]{AsSnoc}

We call this inductive family \IdrisType{AsSnoc} because it allows us to get
a handle on the input list as if it were a \IdrisType{Snoclist}. If the list is
empty then it corresponds to an empty snoclist (constructor \IdrisData{Lin})
but if it is non-empty, we get our hands on the initial segment \IdrisBound{xs},
the last element \IdrisBound{x} and a proof that the list is indeed
(\IdrisBound{xs} \IdrisFunction{++} \IdrisData{[}\IdrisBound{x}\IdrisData{]}).
%
We can finish the view definition by implementing the function \IdrisFunction{asSnoc}
that shows that every list \IdrisBound{xs} can be taken apart in an \IdrisType{AsSnoc}
manner.

\ExecuteMetaData[Snoc.idr.tex]{asSnoc}

The interesting case is the one where the input list is non-empty.
%
Using the \IdrisKeyword{with} keyword we can locally modify the function
definition to have it take an extra argument, here the recursive call to
(\IdrisFunction{asSnoc} \IdrisBound{xs})).
%
Correspondingly, we locally extend the pattern-matching definition with
an additional pattern on the left-hand side of the indented with-clauses.
%
By matching on the result of the recursive call, we get to learn about the
structure of the tail. This is precisely the power of views.

In the clause with the pattern \IdrisData{[<]}, we learn that \IdrisBound{xs} is empty
(hence the \emph{forced} pattern denoted by a full stop
\IdrisKeyword{.(}\IdrisData{[]}\IdrisKeyword{)} that replaces \IdrisBound{xs})
and therefore \IdrisBound{x} is the last element.
%
We can return (\IdrisData{[]} \IdrisData{:<} \IdrisBound{x}) whose index is
(\IdrisData{[]} \IdrisFunction{++} \IdrisData{[}\IdrisBound{x}\IdrisData{]})
which computes to \IdrisData{[}\IdrisBound{x}\IdrisData{]}.

%
In the clause with the pattern (\IdrisBound{ys} \IdrisData{:<} \IdrisBound{y}), we learn
that \IdrisBound{xs} has the shape (\IdrisBound{ys} \IdrisFunction{++} \IdrisBound{y})
which would not be a valid pattern where it not forced.
%
We can conclude by pushing \IdrisBound{x} back onto \IdrisBound{ys}.

Note that compared to a function returning a value of type
{\IdrisType{Maybe} (\IdrisType{List} \IdrisBound{a}\IdrisType{,} \IdrisBound{a})},
we have here the guarantee that the result actually reflects the structure of the
input list.
%
For instance, if we had tried to return \IdrisData{Lin} instead of
(\IdrisData{[]} \IdrisData{:<} \IdrisBound{x}) in the singleton list case,
the program would not have typechecked.

We can now use the view to pattern-match on the list from its end almost as
seamlessly as we can match on its head as is demonstrated by the following
comparison between \IdrisFunction{first} and \IdrisFunction{last}.
%
We have left an empty line in the definition of the former to line up each
equation with the matching one in the latter.

\noindent
\begin{minipage}[t]{0.45\textwidth}
\ExecuteMetaData[Snoc.idr.tex]{first}
\end{minipage}\hfill
\begin{minipage}[t]{0.45\textwidth}
\ExecuteMetaData[Snoc.idr.tex]{last}
\end{minipage}

Our goal is to define a view for \IdrisType{Th} that demonstrates
that any thinning has been built using one of the three smart
constructors introduced in the previous section.

\subsubsection{A View for \IdrisType{Th}}

The \IdrisType{View} family is a sum type indexed by a thinning. It has one
data constructor associated to each smart constructor and storing its arguments.

\ExecuteMetaData[Thin.idr.tex]{view}

The accompanying \IdrisFunction{view} function witnesses the fact that any
thinning arises as one of these three cases.
%
We leave out the slightly technical definition of \IdrisFunction{view}, the
interested reader can find it in the accompanying material.
%
We will however discuss the code it compiles to after erasure in
\cref{sec:compiledview}.

\ExecuteMetaData[Thin.idr.tex]{viewtotal}

We can readily use this function to implement pattern matching functions taking
a thinning apart. We can for instance define \IdrisFunction{kept}, the function
that counts the number of \IdrisFunction{keep} smart constructors used when
manufacturing the input thinning and returns a proof that this is exactly the
length of the source scope \IdrisBound{sx}.

\ExecuteMetaData[Thin.idr.tex]{kept}

We proceed by calling the \IdrisFunction{view} function on the input thinning
which immediately tells us that we only have three cases to consider.
%
The \IdrisData{Done} case is easily handled because the branche's refined
types inform us that both \IdrisBound{sx} and \IdrisBound{sy} are the
empty snoclist \IdrisData{[<]} whose length is evidently \IdrisData{0}.
%
In the \IdrisData{Keep} branch we learn that \IdrisBound{sx} has the shape
(\IdrisBound{\KatlaUnderscore} \IdrisData{:<} \IdrisBound{x}) and so we must return the
successor of whatever the result of the recursive call gives us.
%
Finally in the \IdrisData{Drop} case, \IdrisBound{sx} is untouched and so a
simple recursive call suffices.
%
Note that the function is correctly detected as total because the target scope
\IdrisBound{sy} is indeed getting structurally smaller at every single recursive
call.
%
It is runtime irrelevant but it can still be successfully used as a termination
measure by the compiler.

\subsection{The \IdrisType{Thinning} Relation}\label{sec:thininginternal}

We have shown the user-facing \IdrisType{Th} and have claimed that it is possible
to define smart constructors \IdrisFunction{done}, \IdrisFunction{keep},
and \IdrisFunction{drop}, as well as a \IdrisFunction{view} function.
%
This should become apparent once we show the actual definition of \IdrisType{Thinning}.

\subsubsection{Definition of \IdrisType{Thinning}}

The relation maintains the invariant between the record's
fields \IdrisFunction{bigEnd} (a \IdrisType{Nat})
and \IdrisFunction{encoding} (an \IdrisType{Integer})
and the index scopes \IdrisBound{sx} and \IdrisBound{sy}.

\ExecuteMetaData[Thin/Internal.idr.tex]{thinning}

As always, the \IdrisData{Done} constructor is the simplest.
%
It states that the thinning of size \IdrisData{Z} and encoded as the bit
pattern \IdrisData{0} is the empty thinning.

The \IdrisData{Keep} constructor guarantees that the thinning of
size (\IdrisData{S} \IdrisBound{i}) and encoding \IdrisBound{bs}
represents an injection
from (\IdrisBound{sx} \IdrisData{:<} \IdrisBound{x})
to (\IdrisBound{sy} \IdrisData{:<} \IdrisBound{x})
provided that the bit at position \IdrisData{Z} of \IdrisBound{bs}
is set, and that the rest of the bit pattern (obtained by a right shift
on \IdrisBound{bs}) is a valid thinning of size \IdrisBound{i} from
\IdrisBound{sx} to \IdrisBound{sy}.

The \IdrisData{Drop} constructor is structured the same way, except that
it insists the bit at position \IdrisData{Z} should \emph{not} be set.

We can readily use this relation to prove that some basic encoding are
valid representations of useful thinnings.

\subsubsection{Examples of \IdrisType{Thinning} proofs}

For instance, we can always define a thinning from the empty scope to
an arbitrary scope \IdrisBound{sy}.
%
The \IdrisFunction{encoding} of this thinning is \IdrisData{0} because
every variable is being discarded and its \IdrisFunction{bigEnd} is
the length of the outer scope \IdrisBound{sy}.

\ExecuteMetaData[Thin/Internal.idr.tex]{none}

The proof proceeds by induction over the outer scope \IdrisBound{sy}. If it
is empty, we can simply use the constructor for the empty thinning.
%
Otherwise we can invoke \IdrisData{Drop} on the induction hypothesis.
%
This all typechecks because (\IdrisFunction{testBit} \IdrisData{0} \IdrisData{Z})
computes to \IdrisData{False} and so the \IdrisBound{nb} proof can be constructed
automatically by \idris{}'s proof search (cf. \cref{sec:proofsearch}),
%
and (\IdrisData{0} \IdrisFunction{`shiftR`} \IdrisData{1}) evaluates to \IdrisData{0}
which means the induction hypothesis has exactly the right type.


The definition of the identity thinning is a bit more involved.
%
For a scope of size $k$, we are going to need to generate a bit pattern with
$k$ ones followed by zeros.
%
We define it in two steps.
%
First, \IdrisFunction{cofull} defines a bit pattern of $k$ zeros followed by ones
by shifting $k$ places to the left a bit pattern of ones only.
%
Then, we obtain \IdrisFunction{full} by taking the complement of \IdrisFunction{cofull}.

\noindent
\begin{minipage}{.45\textwidth}
\ExecuteMetaData[Data/Bits/Integer.idr.tex]{cofull}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\ExecuteMetaData[Data/Bits/Integer.idr.tex]{full}
\end{minipage}

We can then prove that the identity thinning for a scope of size \IdrisBound{n} is
represented by the pairing of (\IdrisFunction{full} \IdrisBound{n}) as the
\IdrisFunction{encoding} and \IdrisBound{n} as the \IdrisFunction{bigEnd}.

\ExecuteMetaData[Thin/Internal.idr.tex]{ones}


This proof proceeds once more by induction on the scope.
%
If the scope is empty then once again the constructor for the empty thinning will do.
%
In the non-empty case, we first appeal to an auxiliary lemma (not shown here) to
construct \IdrisBound{nb} a proof that the bit at position \IdrisData{Z} for a
non-zero \IdrisFunction{full} integer is known to be \IdrisData{True}.
%
We then need to use another lemma to cast the induction hypothesis which mentions
(\IdrisFunction{full} (\IdrisFunction{length} \IdrisBound{sx})) so that it may be
used in a position where we expect a proof talking about
(\IdrisFunction{full} (\IdrisFunction{length} (\IdrisBound{sx} \IdrisData{:<} \IdrisBound{x}))
\IdrisFunction{`shiftR`} \IdrisData{1}).

\subsubsection{Properties of the \IdrisType{Thinning} relation}

This relation has a lot of convenient properties.

First, it is proof irrelevant: any two proofs that the same
\IdrisBound{i}, \IdrisBound{bs}, \IdrisBound{sx}, and \IdrisBound{sy} are
related are provably equal.
%
Consequently, equality on \IdrisType{Th} values amounts to equality of
the \IdrisFunction{bigEnd} and \IdrisFunction{encoding} values. In particular
it is cheap to test whether a given thinning is the empty or the
identity thinning.

Second, it can be inverted~\cite{DBLP:conf/types/CornesT95} knowing only two bits:
whether the natural number is empty and what the value of the bit at position
\IdrisData{Z} of the encoding is.
%
This means that \IdrisFunction{view} can be efficiently implemented by using
these two checks and then inverting the \IdrisType{Thinning} proof to gain access
to the proof that the remainder of the thinning's encoding is valid.
%
We will see in \cref{sec:compiledview} that this leads to efficient runtime code for the view.

\subsection{Choose Your Own Abstraction Level}

Access to both the high-level \IdrisType{View} and the internal \IdrisType{Thinning}
relation means that programmers can pick the level of abstraction at which they
want to work.
%
They may need to explicitly manipulate bits to implement key operators that are used
in performance-critical paths but can stay at the highest level for more negligible
operations, or proofs.

\todo{Insert example e.g. meet and its proof!}

When working with co-de Bruijn terms, it is convenient to define a view where one
`layer' of term has been opened.
\todo{explain term layer}

The following diagram shows the correspondance between an `opened' application node
using the view (the diamond `\$' node) and its co-de Bruijn form (the circular
`\$' node).

\noindent
\begin{minipage}{.45\textwidth}\center
  \ExecuteMetaData[ast.tex]{opened}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}\center
  \ExecuteMetaData[ast.tex]{opening}
\end{minipage}

The outer thinning of the co-de Bruijn term is obtained by computing the join of
the respective outer thinnings of the application's function and argument.
%
This is a good example of an operation that can be implemented by induction and
case analysis just like we would with a typical inductive family, or directly
by taking the disjunction of the bit pattern encodings of the thinnings.

\todo{include both definitions}

\subsection{Compiled Code}\label{sec:compiledview}

The following code block shows the javascript code that is produced when compiling the
\IdrisFunction{view} function. We chose to use the javascript backend rather than e.g.
the chezscheme one because it produces fairly readable code.
%
We have modified the backend to also write comments reminding the reader of the type
of the function being defined and the data constructors the natural number tags
correspond to.

The only manual modifications we have performed are the inlining of a function
corresponding to a \IdrisKeyword{case} block, renaming variables and property names
to make them human-readable, introducing the \texttt{\$tail} definitions to make
lines shorter, and slightly changing the layout.

\input{view}

Readers can see that the compilation process has erased all of the indices
and the proofs
showing that the invariant tying the efficient runtime representation to the
high-level specification is maintained.
%
A thinning is represented at runtime by a javascript object with two properties
corresponding to \IdrisType{Th}'s runtime relevant fields: \IdrisFunction{bigEnd}
and \IdrisFunction{encoding}.
%
Both are storing a javascript \texttt{bigInt} (one corresponding to the
\IdrisType{Nat}, the other to the \IdrisType{Integer}).
%
For instance the thinning [01101] would be at runtime
\mintinline{javascript}{{ bigEnd: 5n, encoding: 13n }}.
%

The view proceeds in two steps. First if the \texttt{bigEnd} is \texttt{0n}
then we know the thinning is empty and can immediately return the \IdrisData{Done}
constructor.
%
Otherwise we know the thinning to be non-empty and so we can compute the big end
of its tail (\texttt{\$predBE}) by subtracting one to the non-zero \texttt{bigEnd}.
We can then inspect the bit at position \texttt{0} to decide whether to return a
\IdrisData{Keep} or a \IdrisData{Drop} constructor. This is performed by using a
bit mask to 0-out all the other bits (\texttt{\$th.bigEnd\&1n}) and checking whether
the result is zero.
%
If it is not equal to 0 then we emit \IdrisData{Keep} and compute the \texttt{\$tail}
of the thinning by shifting the original encoding to drop the 0th-index. Otherwise we
emit \IdrisData{Drop} and compute the same tail.

By running \IdrisFunction{view} on this [01101] thinning, we would get
back (\IdrisData{Keep} [0110]), that is to say
\mintinline{javascript}{{ tag: 1, val: { bigEnd: 4n, encoding: 6n } }}.

Thanks to \idris{}'s implementation of Quantitative Type Theory we have managed
to manufacture a high level representation that can be manipulated like a classic
inductive family using smart constructors and views without giving up an inch of
control on its runtime representation.
