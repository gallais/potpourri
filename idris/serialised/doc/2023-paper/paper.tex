\documentclass{article}

\usepackage{idris2}
\usepackage{catchfilebetweentags}
\input{robust-catch}

\usepackage{fullpage}

\title{A Universe for Serialised Data}
\author{Guillaume Allais}

\newcommand{\idris}{Idris 2}
\newcommand{\assertTotal}{\IdrisPostulate{assert\KatlaUnderscore{}total}}

\begin{document}

\maketitle

\begin{abstract}
In typed functional languages, one can typically only manipulate data
in a type-safe manner if it first has been deserialised into an in-memory
tree represented as a graph of nodes-as-structs and subterms-as-pointers.

We demonstrate how we can use QTT as implemented in \idris{} to define
a small universe of serialised datatypes, and provide generic programs
allowing users to process values stored contiguously in buffers.

Our approach allows implementors to prove the full functional correctness,
in a correct by construction manner, of the IO functions processing the
data stored in the buffer.
\end{abstract}

\section{Introduction}

\section{Descriptions}

Descriptions are essentially arbitrarily nested tuples of
values of type unit,
bytes,
and recursive substructures.

Our type of description has three indices corresponding to three important
invariants being tracked.
%
First, the statically known size of the described data.
%
Second, the number of offsets that need to be stored to compensate for the
fact that some subterms do not have a statically known size.
%
Third, whether the current description is being used in the rightmost branch
of the overall layer description.

\ExecuteMetaData[Serialised/Desc.idr.tex]{desc}


\ExecuteMetaData[Serialised/Desc.idr.tex]{constructor}

A datatype description is given by a list of constructor descriptions.

\ExecuteMetaData[Serialised/Desc.idr.tex]{data}


\ExecuteMetaData[Serialised/Desc.idr.tex]{treedesc}



\section{Meaning as Trees}

\subsection{\IdrisType{Desc}s as Functors}

We can define the meaning of descriptions as strictly positive
endofunctors on \IdrisType{Type} by induction on said descriptions.
%
\IdrisFunction{Meaning} gives us the action of the functors on objects
while \IdrisFunction{fmap} gives us their action on morphisms.
%
Verifying that these definitions respect the functor laws is left as
an exercise for the reader.

Both \IdrisData{None} and \IdrisData{Byte} are interpreted by constant
functors (respectively the one return the unit type, and the one returning
the type of bytes),
%
(\IdrisData{Prod} \IdrisBound{d} \IdrisBound{e}) is interpreted as the
pairing of the interpretation of \IdrisBound{d} and \IdrisBound{e} respectively,
%
and \IdrisData{Rec} is the identity functor.

\ExecuteMetaData[Serialised/Desc.idr.tex]{meaning}



\ExecuteMetaData[Serialised/Desc.idr.tex]{fmap}

\subsection{\IdrisType{Data} as Trees}

We can define the type of algebras for the functor described by a
\IdrisType{Data} description as follows
%: for each choice of constructor
%(\IdrisType{Fin} (\IdrisFunction{length} \IdrisBound{cs})),
%we can collapse a layer

\ExecuteMetaData[Serialised/Desc.idr.tex]{alg}

We can then define the fixpoints of functors as


\ExecuteMetaData[Serialised/Desc.idr.tex]{mu}

%
Note that here we are forced to use \assertTotal{} to force \idris{}
to accept the definition.
%
Indeed, unlike Agda, \idris{} does not (yet!) track whether a function's
arguments are used in a strictly positive manner.
%
Consequently the positivity checker
is unfortunately unable to see that \IdrisFunction{Meaning} uses its second
argument in a strictly positive manner
and that this is therefore a legal definition.

\IdrisType{Mu} give us the initial fixpoint for these algebras i.e.
we have a \IdrisFunction{fold} function. Here we only use \assertTotal
for convenience but this could easily be bypassed by mutually defining
an inlined and specialised version of
(\IdrisFunction{fmap} (\IdrisFunction{fold} \IdrisBound{alg})).

\ExecuteMetaData[Serialised/Desc.idr.tex]{fold}

We can define convenient aliases for the \IdrisFunction{Tree} constructors.

\ExecuteMetaData[Serialised/Desc.idr.tex]{leaf}
\ExecuteMetaData[Serialised/Desc.idr.tex]{node}

This enables us to define our running example.

\ExecuteMetaData[Serialised/Desc.idr.tex]{example}

\section{Meaning as Pointers into a Buffer}




\end{document}
