\section{Meaning as Pointers into a Buffer}\label{sec:pointers}

Now that we know the serialisation format, we can give a meaning
to constructor and data descriptions as pointers into a buffer.

\subsection{Tracking Buffer Positions}

We start with the definition of the counterpart to \IdrisType{Mu}
for serialised values. A tree sitting in a buffer is represented
by the pairing of the buffer and the offset at which the tree's
root node is stored.

\ExecuteMetaData[SaferIndexed.idr.tex]{pointermu}

For reasons that will become apparent in \Cref{sec:bufferfold}
when we start programming over serialised data in a correct-by-construction
manner the record \IdrisType{Mu} is parameterised not only by the description
of the data type stored but also by a runtime-irrelevant inductive value of
that type.

\ExecuteMetaData[SaferIndexed.idr.tex]{elem}

Once we have a type of pointers into values stored in the buffer
we can start looking at what is actually stored.
%
But first let us have a look at the \IdrisType{Singleton} family
which will help us connect the values we read or compute to their
runtime-irrelevant type-level counterparts.

\input{singleton}

\subsection{Poking the Buffer}

Our most basic operation consists in poking the buffer to unfold
the description by exactly one step.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokefun}

The result type of this operation is defined by case-analysis on the
description. In order to keep the notations user-friendly, we
mutually define
a recursive function \IdrisFunction{Poke} interpreting the straightforward type constructors
and an inductive family \IdrisType{Poke'} with interesting return indices.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokedatafun}

Poking a buffer containing \IdrisData{None} will return a value of
the unit type as no information whatsoever is stored there.

If we access a \IdrisData{Byte} then we expect that inspecting the
buffer will yield a runtime-relevant copy of the type-level byte we
have for reference. Hence the use of \IdrisType{Singleton}.

If we access a \IdrisData{Prod} of two descriptions then the type-level term
better be a pair and we better be able to obtain a \IdrisType{Pointer.Meaning}
to each of the sub-meanings.
%
Because \idris{} does not currently support definitional eta equality
for records, it will me more ergonomic for users if we introduce
\IdrisType{Poke'} rather than yielding a \IdrisType{Tuple} of values.

Last but not least if the description is \IdrisData{Rec} this means
we have a substructure. In this case we simply demand a pointer to it.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokedatadata}

The implementation of this operation proceeds by case analysis
on the description.
%
As we are going to see shortly, it is necessarily somewhat unsafe
as we claim to be able to connect a type-level value to whatever
it is that we read from the buffer.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokefunNone}

If the description is \IdrisData{None} we do not need to fetch any
information from the buffer.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokefunByte}

If the description is \IdrisData{Byte} then we read a byte at the
determined position. The only way we can connect this value we just
read to the type index is to use the unsafe combinator
\IdrisPostulate{unsafeMkSingleton} to manufacture a value of type
(\IdrisType{Singleton} \IdrisBound{t}) instead of the value of type
(\IdrisType{Singleton} \IdrisBound{bs})
we would expect from wrapping \IdrisBound{bs} in the \IdrisData{MkSingleton} constructor.


\ExecuteMetaData[SaferIndexed.idr.tex]{pokefunProd}

If the description is the product of two sub-descriptions then we
want to compute the \IdrisType{Pointer.Meaning} corresponding to
each of them.
%
We start by splitting the vector of offsets to distribute them between
the left and right subtrees.
%
We can readily build the pointer for the \IdrisBound{left} subdescription:
it takes the left offsets, the buffer, and has the same starting position
as the whole description of the product as they are stored one after the other.
%
We then compute the starting position of the right subtree: we need to
move past the whole of the left subtree, that is to say past the space
reserved by all of the left offsets (\IdrisFunction{sum} \IdrisBound{subl})
but also past the content whose size is known statically (\IdrisBound{sl}).
%
We can finally use an eta-equality lemma to turn \IdrisBound{t} into
(\IdrisFunction{fst} \IdrisBound{t} \IdrisData{\#} \IdrisFunction{snd} \IdrisBound{t})
which lets us use the \IdrisType{Poke'} constructor \IdrisData{(\#)} to return our
pair of pointers.

\ExecuteMetaData[SaferIndexed.idr.tex]{pokefunRec}

Lastly, when we reach a \IdrisData{Rec} description, we can discard the
vector of offsets and return a \IdrisType{Pointer.Mu} with the same buffer
and starting position as our input pointer.

\subsection{Extracting one layer}

By repeatedly poking the buffer, we can unfold a full layer.
The result of this operation is defined by induction
on the description. It is identical to the definition of
\IdrisFunction{Poke} except for the \IdrisData{Prod} case:
here, instead of being content with a pointer for each of the
subdescriptions, we demand a full layer for them too.

\ExecuteMetaData[SaferIndexed.idr.tex]{layerdata}

This function can easily be implemented by induction on the description
and repeatedly calling \IdrisFunction{poke} to expose the values one by
one.

\ExecuteMetaData[SaferIndexed.idr.tex]{layerfun}

\subsection{Exposing the top constructor}

\todo{remind people of the serialisation format here}

Now that we can deserialise an entire layer of \IdrisFunction{Meaning},
the only thing we are missing to be able to generically manipulate trees
is the ability to expose the top constructor of a tree stored at a
\IdrisType{Pointer.Mu} position.
%
The \IdrisType{Out} family describes what it means to get your hands on
the index of a tree's constructor: you obtain an \IdrisType{Index},
and a \IdrisType{Pointer.Meaning} to the constructor's payload.
%
The return type ensures that the structure of the tree is adequately
described by combining both components.

\ExecuteMetaData[SaferIndexed.idr.tex]{outdata}

The type of the \IdrisFunction{out} is as expected: given a pointer
to a tree \IdrisBound{t} of type \IdrisBound{cs} we can get a value
of type (\IdrisType{Out} \IdrisBound{cs} \IdrisBound{t}).
%
That is to say, we can get a view allowing us to reveal what the
index of the tree's head constructor is.

\ExecuteMetaData[SaferIndexed.idr.tex]{outfun}

The implementation is fairly straightforward except for another
unsafe step meant to reconcile the information we read in the buffer
with the runtime-irrelevant tree index.

\ExecuteMetaData[SaferIndexed.idr.tex]{outfunbody}

We start by reading the tag \IdrisBound{k}
corresponding to the constructor choice:
we obtain a byte by calling \IdrisFunction{getBits8}, cast it to a
natural number and then make sure that it is in the range
$[0 \cdots \text{\IdrisFunction{consNumber} \IdrisBound{cs}}[$ using
\IdrisFunction{natToFin}.
%
We then use the unsafe \IdrisPostulate{unfoldAs} primitive to step the
type-level \IdrisBound{t} to something of the form
(\IdrisBound{k} \IdrisData{\#} \IdrisBound{val}).
The declaration of \IdrisPostulate{unfoldAs} is marked as runtime
irrelevant because it cannot possibly be implemented
(\IdrisBound{t} is runtime irrelevant and so cannot be inspected)
and so should its output should not be relied upon in runtime-relevant
computations.

\ExecuteMetaData[Serialised/Desc.idr.tex]{unfoldAs}

Now that we know the head constructor we want to deserialise and that
we have the ability to step the runtime irrelevant tree to match the
actual content of the buffer, we can use \IdrisFunction{getConstructor}
to build such a value.

\ExecuteMetaData[SaferIndexed.idr.tex]{getConstructor}

\todo{explain}

\ExecuteMetaData[SaferIndexed.idr.tex]{getOffsets}

The implementation of \IdrisType{getOffsets} is straightforward: given
a continuation that expect \IdrisBound{n} offsets as well as the
position past the last of these offsets, we read the 8-bytes-long
offsets one by one and pass them to the continuation, making sure
that we move the current position accordingly before every recursive call.

\subsection{Offering a convenient \IdrisType{View}}

We can combine \IdrisFunction{out} and \IdrisFunction{layer} to obtain
the \IdrisFunction{view} function we used in our introductory examples
in~\Cref{sec:seamless}.
%
A (\IdrisType{View} \IdrisBound{cs} \IdrisBound{t}) value gives us
access to the (\IdrisType{Index} \IdrisBound{cs}) of
\IdrisBound{t}'s top constructor together with the corresponding
\IdrisFunction{Layer} of deserialised values.

\ExecuteMetaData[SaferIndexed.idr.tex]{viewdata}

The implementation of \IdrisFunction{view} is unsurprising: we use
\IdrisFunction{out} to expose the top constructor index and a
\IdrisType{Pointer.Meaning} to the constructor's payload.
%
We then user \IdrisFunction{layer} to extract the full
\IdrisFunction{Layer} of deserialised values that the
pointer references.

\ExecuteMetaData[SaferIndexed.idr.tex]{viewfun}
\ExecuteMetaData[SaferIndexed.idr.tex]{viewfunbody}

These are views
(in the sense of Wadler~\cite{DBLP:conf/popl/Wadler87},
and McBride and McKinna~\cite{DBLP:journals/jfp/McBrideM04})
\todo{explain and move earlier}

It is worth noting that although a \IdrisFunction{view} may be
convenient to consume, a performance-minded user may decide to
directly use the \IdrisFunction{out} and \IdrisFunction{poke}
combinators to avoid deserialising values that they do not need.
%
For instance, given a binary tree storing strings in its nodes and
natural numbers at its leaves, if the user only wants to extract the
rightmost natural number in the tree there is no need to deserialise
all of the strings encountered on the way down.

\todo{Add rightmost and rightmost' as case studies in an appendix?}

\subsection{Generic Fold}\label{sec:bufferfold}

The implementation of the generic \IdrisFunction{fold} over a tree stored
in a buffer is going to have the same structure as the generic fold over
inductive values: first match on the top constructor, then use \IdrisFunction{fmap}
to apply the fold to all the substructures and, finally, apply the algebra to
the result.
%
We start by implementing the buffer-based counterpart to \IdrisFunction{fmap}.
Let us go through the details of its type first.

\ExecuteMetaData[SaferIndexed.idr.tex]{fmaptype}

The first two arguments to \IdrisFunction{fmap} are similar to its pure
counterpart: a description \IdrisBound{d} and a runtime-irrelevant function
\IdrisBound{f} to map over a \IdrisFunction{Meaning}.
%
Next we take a function which is the buffer-aware counterpart to \IdrisBound{f}:
given any runtime-irrelevant term \IdrisBound{t} and a pointer to it in a buffer,
it returns an \IdrisType{IO} process computing the value (\IdrisBound{f} \IdrisBound{t}).
%
Finally, we take a runtime-irrelevant meaning \IdrisBound{t}
as well as a pointer to its representation in a buffer and compute
an \IdrisType{IO} process which will return a value equal to
(\IdrisFunction{Data.fmap} \IdrisBound{d} \IdrisBound{f} \IdrisBound{t}).

We can now look at the definition of \IdrisFunction{fmap}.

\ExecuteMetaData[SaferIndexed.idr.tex]{fmapfun}

We poke the buffer to reveal the value the \IdrisType{Pointer.Meaning}
named \IdrisBound{ptr} is pointing at and then dispatch over the description
\IdrisBound{d} using the \IdrisFunction{go} auxiliary function.

\todo{No we don't (anymore)}
If the description is \IdrisData{None} we rewrite by the lemma
\IdrisFunction{etaUnit} which proves that all the values of the unit type
are equal to \IdrisData{()}. This then allows us to return \IdrisData{()}.

If the description is \IdrisData{Byte}, the value is left untouched and so
we can simply return it immediately.

If we have a \IdrisData{Prod} of two descriptions, we recursively apply
\IdrisFunction{fmap} to each of them and pair the results back.

Finally, if we have a \IdrisData{Rec} we apply the function operating
on buffers that we know performs the same computation as \IdrisBound{f}.


We can now combine \IdrisFunction{out} and \IdrisFunction{fmap} to compute
the correct-by-construction \IdrisFunction{fold}: provided an algebra for
a datatype \IdrisBound{cs} and a pointer to a tree of type \IdrisBound{cs}
stored in a buffer, we return an \IdrisType{IO} process computing the fold.

\ExecuteMetaData[SaferIndexed.idr.tex]{fold}

We first use \IdrisFunction{out} to reveal the constructor choice in the
tree's top node, we then recursively apply (\IdrisFunction{fold} \IdrisBound{alg})
to all the substructures by calling \IdrisFunction{fmap}, and we conclude by
applying the algebra to this result.

We once again (cf. \Cref{sec:genericfoldinductive}) had to
use \assertTotal{} because it is not obvious to
\idris{} that \IdrisFunction{fmap} only uses its argument on subterms.
%
This could have also been avoided by mutually defining \IdrisFunction{fold}
and a specialised version of
(\IdrisFunction{fmap} \IdrisKeyword{(}\IdrisFunction{fold} \IdrisBound{alg}\IdrisKeyword{)})
at the cost of code duplication and obfuscation.
%
We once again include such a definition in \Cref{sec:safefold}.
