\section{Serialising Data}\label{sec:serialising}

So far all of our example programs involved taking an inductive value
apart and computing a numeric value.
%
But we may instead want to compute another value in serialised form.
%
In this section we are going to spell out how we can define high-level
constructs allowing users to do just that in a correct-by-construction
manner.



\ExecuteMetaData[SaferIndexed.idr.tex]{serialisedmap}\label{fig:serialised-map}

%% \subsection{Generic Traverse}
%% \ExecuteMetaData[SaferIndexed.idr.tex]{traverse}

\subsection{The Type of Serialisation Processes}

A serialisation process for a tree \IdrisBound{t} that belongs to the
datatype \IdrisBound{cs} is a function that takes a buffer
and a starting offset and returns an \IdrisType{IO} process that
serialises the term in the buffer at that offset and computes the
offset of the first byte past the serialised tree.

\ExecuteMetaData[SaferIndexed.idr.tex]{serialising}


\subsection{Constructings subterms}

\ExecuteMetaData[SaferIndexed.idr.tex]{allquant}
\ExecuteMetaData[SaferIndexed.idr.tex]{dataallquant}

We can then use the \IdrisType{All} quantifier to state that given a
valid serialisation process for all of a top node's subterms, we can
successfully define a serialising process for said node.

\ExecuteMetaData[SaferIndexed.idr.tex]{serialisemu}

The keen reader may refer to the accompanying code to see the implementation.
Informally (cf. \Cref{sec:tree-serialisation} for the description of the format):
first we write the tag corresponding to the choice of constructor,
then we leave some space for the offsets,
in the meantime we write all of the node's payloads and collect the offsets while doing so,
and finally we fill in the space we had left blank with the offsets we have now collected.

\subsection{Copying subterms}

We introduce a \IdrisFunction{copy} combinator for terms that we want to
serialise as-is.
%
Equipped with this combinator, we are able to easily write e.g.
the \IdrisFunction{swap} function which takes a binary tree apart
and swaps its left and right branches (if the tree is non-empty).

\ExecuteMetaData[SaferIndexed.idr.tex]{swap}


This combinator is implemented using the \IdrisFunction{copyData} primitive
for \IdrisType{Buffer}s which saves us from having to traverse the whole term
simply to output it.
%
It will instead grab a slice of the source buffer corresponding to the term
and copy the raw bytes directly into the target buffer.

\ExecuteMetaData[SaferIndexed.idr.tex]{copy}

This is the one combinator that crucially relies on the fact that our format
only uses offsets and not absolute addresses
and that the size information we have been keeping in \IdrisType{Pointer.Mu} and
\IdrisType{Pointer.Meaning} is accurate.

\subsection{Executing a Serialisation Action}

Now that we can describe actions serialising a value to a buffer,
the only basic building block we are missing is a function actually
performning such actions.
%
This is provided by the \IdrisFunction{execSerialising} function
declared below.

\ExecuteMetaData[SaferIndexed.idr.tex]{execSerialising}

By executing a (\IdrisType{Serialising} \IdrisBound{cs} \IdrisBound{t}), we
obtain an \IdrisType{IO} process returning a pointer to the tree \IdrisBound{t}
stored in a buffer.
%
We can then either compute further with this tree (e.g. by calling
\IdrisFunction{sum} on it), or write it to a file for safekeeping.

\subsection{Evaluation Order}

The careful reader may have noticed that we can and do run arbitrary \IdrisType{IO}
operations when building a value of type \IdrisType{Serialising}
(cf. the \IdrisFunction{map} example in \Cref{fig:serialised-map}).

\todo{discuss bind and interleaving}

This allows us to interleave reading from the original buffer and
writing into the target one.
