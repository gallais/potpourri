
\section{Serialised Representation}

In the following binary dump, each byte is represented by a pair of
hexadecimal digits.
%
The raw data is semantically highlighted: \hexaoffset{offsets},
\hexadesc{type} of the stored data, \hexacons{nodes} of the
tree and \hexadata{data} stored.
%
This specific block is the encoding of the \IdrisFunction{example} included
below and,
%
knowing that \IdrisFunction{leaf} is represented by \hexacons{00}
and \IdrisFunction{node} is represented by \hexacons{01}
%
the careful reader can check
(modulo ignoring the type description and offsets for now)
that the data is stored in a depth-first, left-to-right traversal of the tree.

\begin{hexdump}
87654321  00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
00000000: \hexaoffset{07 00 00 00 00 00 00 00} \hexadesc{02 00 02 03 02 01 03} \hexacons{01}
00000010: \hexaoffset{17 00 00 00 00 00 00 00} \hexacons{01} \hexaoffset{0c 00 00 00 00 00 00}
00000020: \hexaoffset{00} \hexacons{01} \hexaoffset{01 00 00 00 00 00 00 00} \hexacons{00} \hexadata{01} \hexacons{00} \hexadata{05} \hexacons{00} \hexadata{0a}
00000030: \hexacons{01} \hexaoffset{01 00 00 00 00 00 00 00} \hexacons{00} \hexadata{14} \hexacons{00}
\end{hexdump}

\ExecuteMetaData[Serialised/Desc.idr.tex]{example}



offsets are 8 bytes each and record just enough information to
allow us to jump past parts of the data that we do not require (e.g. finding
the rightmost node can be done without deserialising any left branch),

the type of the data being stored is encoded so that loading
can be done in safe mode
