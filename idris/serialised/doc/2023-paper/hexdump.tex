\section{Serialised Representation}\label{sec:hexdump}

Before we can define the meaning of our descriptions as pointers
into buffers, we need to decide on a serialised representation of
our trees.

The following binary snippet is a hex dump of a file containing
the serialised representation of a binary tree belonging to the
type we have been using as our running example.
%
The raw data is semantically highlighted: various bytes spans
correspond to
\hexaoffset{offsets},
\hexadesc{type} description of the stored data,
\hexacons{nodes} of the tree
and \hexadata{data} stored in the nodes.

\begin{hexdump}
87654321  00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
00000000: \hexaoffset{07 00 00 00 00 00 00 00} \hexadesc{02 00 02 03 02 01 03} \hexacons{01}
00000010: \hexaoffset{17 00 00 00 00 00 00 00} \hexacons{01} \hexaoffset{0c 00 00 00 00 00 00}
00000020: \hexaoffset{00} \hexacons{01} \hexaoffset{01 00 00 00 00 00 00 00} \hexacons{00} \hexadata{01} \hexacons{00} \hexadata{05} \hexacons{00} \hexadata{0a}
00000030: \hexacons{01} \hexaoffset{01 00 00 00 00 00 00 00} \hexacons{00} \hexadata{14} \hexacons{00}
\end{hexdump}

More spefically, this block is the encoding of the \IdrisFunction{example}
given in the previous section and,
%
knowing that a \IdrisFunction{leaf} is represented by \hexacons{00}
and a \IdrisFunction{node} is represented by \hexacons{01}
%
the careful reader can check
(modulo ignoring the type description and offsets for now)
that the data is stored in a depth-first, left-to-right traversal of the tree.



offsets are 8 bytes each and record just enough information to
allow us to jump past parts of the data that we do not require (e.g. finding
the rightmost node can be done without deserialising any left branch),

the type of the data being stored is encoded so that loading
can be done in safe mode
