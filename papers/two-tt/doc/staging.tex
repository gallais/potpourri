\documentclass{article}

%%% Remark environment
\usepackage{amsthm}
\newtheorem*{remark}{Remark}

%%%% Agda code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{agda}
\input{unicode}
\usepackage{catchfilebetweentags}
\input{robust-catch}
% do not indent code blocks
\setlength\mathindent{0em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\setuptodonotes{inline}

\input{commands}

%%% References
\usepackage{hyperref}
\usepackage[style=alphabetic]{biblatex}
\bibliography{staging.bib}

%%% Inference rules
\usepackage{mathpartir}

\title{Scoped and Typed Staging by Evaluation}
\author{Guillaume Allais}

\begin{document}

\maketitle

\section{Introduction}

This paper gives an intrinsically scoped-and-typed
treatment of a simply typed version of the staged compilation
with two-level type theory introduced by
Kov{\'{a}}cs~\cite{DBLP:journals/pacmpl/Kovacs22}.
%
We use Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do)
and mobilise standard formalisation techniques and structures
extensively studied by Allais, Chapman,
McBride, and McKinna~\cite{DBLP:conf/cpp/Allais0MM17}.

Starting from a language with a static and a dynamic layer,
we perform a type-directed model construction
and define an evaluation function turning terms
into their semantical counterpart.
%
As a corollary, we obtain a staging function that
fully evaluates all of the static subterms and returns
purely dynamic ones.

As already observed by Kov{\'{a}}cs, this model construction
is analogous to the one used for normalisation by evaluation,
hence the title of this paper.

\section{A Primer on Intrisically Typed λ-Calculi}

Let us start with a quick primer on intrinsically typed λ-calculi
defined in a dependently typed host language.
%
We first give a sum type of object types: \AIC{`ℕ} stands
for the type of natural numbers and (\AB{A} \AIC{`⇒} \AB{B})
for the type of functions from \AB{A} to \AB{B}.

\ExecuteMetaData[STLC.tex]{type}

\begin{remark}[Syntax Highlighting]
  All the code in this paper is semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}.
\end{remark}

We extensively use Agda's \AK{variable} mechanism: all of
the seemingly unbound names will in fact be automatically
quantified over in a prenex position provided that they
have been declared beforehand.
%
The following block for instance announces that from now
on unbound \AB{A}s and \AB{B}s stand for implicitly bound
\AD{Type} variables.

\ExecuteMetaData[STLC.tex]{typevariables}

Next, we form contexts as left-nested lists of types.
Contexts may be the empty context \AIC{ε}
or a compound context (\AB{Γ} \AIC{,} \AB{A}) obtained
by extending an existing context \AB{Γ} on the right
with a newly bound variable of type \AB{A}.

\ExecuteMetaData[STLC.tex]{context}

\ExecuteMetaData[STLC.tex]{forall}
\ExecuteMetaData[STLC.tex]{update}
\ExecuteMetaData[STLC.tex]{arrow}


\ExecuteMetaData[STLC.tex]{var}
\ExecuteMetaData[STLC.tex]{varnormalised}

\begin{mathpar}
  \inferrule{x : A ∈}{⊢ x : A}

  \inferrule{⊢ f : A → B \and ⊢ t : A}{⊢ f \, t : B}

  \inferrule{x : A ⊢ b : B}{⊢ λx.b : A → B}
\end{mathpar}

\ExecuteMetaData[STLC.tex]{term}


\section{An Intrinsically Typed 2 Level Type Theory}

\todo{start with examples}


\subsection{Stages and Types}

Our notion of types is going to be explicitly indexed by the
stage they live in, and so we begin by defining a sum
type \AD{Stage} with two constructors: \AIC{static},
and \AIC{dynamic}.

\ExecuteMetaData[TwoTT.tex]{stage}

We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[TwoTT.tex]{types}

We have both static and dynamic natural numbers,
hence the unconstrained index \AB{st} for the
constructor \AIC{`ℕ}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.
%
Last but not least, we have an example of the fact,
highlighted in Kov{\'{a}}cs' original paper, that static
datatypes do not need to have a counterpart at runtime:
pairs are only available in the static layer and all traces
of pairs will have completely disappeared after staging.

\subsection{Contexts and Variables}

In order to closely match our usual mathematical notations,
contexts are defined as left-nested lists of types.

\ExecuteMetaData[TwoTT.tex]{context}

Contexts can either be empty (written \AIC{ε})
or take an existing context \AB{Γ} and extend it on the
right with a newly bound variable of type \AB{σ}
(written \AB{Γ} \AIC{,} \AB{σ}).
Note that the stage of the newly bound variable is
existentially quantified.

Once we have contexts, we can formalise what it means
for a variable of type \AB{σ} to be present in context \AB{Γ}.
This is a standard definition corresponding to a scoped-and-typed
variant of de Bruijn index~\cite{de1972lambda}.

\ExecuteMetaData[TwoTT.tex]{var}

Here we used notations meant to once again mimick inference
rules~\cite{DBLP:conf/cpp/Allais0MM17}.
\todo{Add inference rules}

\subsection{Intrinsically Scoped and Typed Syntax}

\ExecuteMetaData[TwoTT.tex]{term}

We introduce two aliases.
%
First, \AF{Source} for the terms users can write and that
may that can mention quotes, splices, pairs, and projections.
%
Second, \AF{Staged} for our target language where all the
static subterms have been evaluated away.

\ExecuteMetaData[TwoTT.tex]{termaliases}

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an \AF{eval}uation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.

\ExecuteMetaData[TwoTT.tex]{evaldecl}

As a direct corollary we will obtain a staging function
that takes a closed dynamic term and gets rid of all of
the quotes, splices, and pairs and projections by fully
evaluating all of its static parts.

\ExecuteMetaData[TwoTT.tex]{stagedecl}

We start with the model construction describing precisely
the type of values.

\subsection{Model Construction}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as terms
guaranteed not to contain any static subterm.

\ExecuteMetaData[TwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation
construction~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{modelstadecl}
\ExecuteMetaData[TwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

Static values of type \AIC{`ℕ} are constant natural numbers;
those of type (\AIC{`⇑} \AB{A}) are dynamic values of type \AB{A}
i.e. staged terms of type \AB{A};
functions from \AB{A} to \AB{B} are interpreted using Kripke function
spaces from static values of type \AB{A} to static values of type \AB{B};
and finally static pairs are pairs of static values.

\ExecuteMetaData[TwoTT.tex]{thin}

\ExecuteMetaData[TwoTT.tex]{kripke}

\ExecuteMetaData[TwoTT.tex]{thinrefl}

\ExecuteMetaData[TwoTT.tex]{kripkeapp}


\subsection{Evaluation}

We can explain what the meaning of each term constructor is.
In every instance we will proceed by case analysis on the
stage the meaning is being used at.


The term constructor \AIC{`zero} is either interpreted by
the natural number \AN{0} or by the term constructor itself
depending on whether it is used in a static or dynamic manner.

\ExecuteMetaData[TwoTT.tex]{zero}

Similarly \AIC{`succ} is interpreted either as (\AN{1} \AF{+}\AS{\_})
if it used in a static manner or by the term constructor itself
for dynamic uses.

\ExecuteMetaData[TwoTT.tex]{succ}

Application is interpreted as the semantic application defined
for Kripke function spaces in the static case, and the syntactic
\AIC{`app} constructor in the dynamic one.

\ExecuteMetaData[TwoTT.tex]{app}



\ExecuteMetaData[TwoTT.tex]{lam}


\ExecuteMetaData[TwoTT.tex]{extend}

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{evaldecl}
\ExecuteMetaData[TwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{bodydecl}
\ExecuteMetaData[TwoTT.tex]{body}
\end{AgdaSuppressSpace}



\section{Future Work}

\cite{DBLP:journals/lisp/Coquand02}

\newpage
\printbibliography

\end{document}
