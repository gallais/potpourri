\documentclass{article}

%%% Remark environment
\usepackage{amsthm}
\newtheorem*{remark}{Remark}

%%%% Agda code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{agda}
\input{unicode}
\usepackage{catchfilebetweentags}
\input{robust-catch}
% do not indent code blocks
\setlength\mathindent{0em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\setuptodonotes{inline}

\input{commands}

%%% References
\usepackage{hyperref}
\usepackage[style=alphabetic]{biblatex}
\bibliography{staging.bib}

\title{Scoped and Typed Staging by Evaluation}
\author{Guillaume Allais}

\begin{document}

\maketitle

\section{Introduction}

This paper gives an intrinsically scoped-and-typed
treatment of a simply typed version of the staged compilation
with two-level type theory introduced by
Kov{\'{a}}cs~\cite{DBLP:journals/pacmpl/Kovacs22}.
%
We use Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do)
and mobilise standard formalisation techniques and structures
extensively studied by Allais, Chapman,
McBride, and McKinna~\cite{DBLP:conf/cpp/Allais0MM17}.

Starting from a language with a static and a dynamic layer,
we perform a type-directed model construction
and define an evaluation function turning terms
into their semantical counterpart.
%
As a corollary, we obtain a staging function that
fully evaluates all of the static subterms and returns
purely dynamic ones.

As already observed by Kov{\'{a}}cs, this model construction
is analogous to the one used for normalisation by evaluation,
hence the title of this paper.

\section{A Primer on Intrisically Typed Calculi}

\section{An Intrinsically Typed 2 Level Type Theory}

\todo{start with examples}


\subsection{Stages and Types}

Our notion of types is going to be explicitly indexed by the
stage they live in, and so we begin by defining a sum
type \AD{Stage} with two constructors: \AIC{static},
and \AIC{dynamic}.

\ExecuteMetaData[TwoTT.tex]{stage}

\begin{remark}[Syntax Highlighting]
  All the code in this paper is semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}.
\end{remark}

We extensively use Agda's \AK{variable} mechanism: all of
the seemingly unbound names will in fact be automatically
quantified over in a prenex provided that they have been
declared beforehand.
%
The following block for instance announces that from now
on unbound \AB{st}s, \AB{a}s, and \AB{b}s stand for
implicit \AD{Stage} variables.

\ExecuteMetaData[TwoTT.tex]{stagevariables}


We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[TwoTT.tex]{types}

We have both static and dynamic natural numbers,
hence the unconstrained index \AB{st} for the
constructor \AIC{`ℕ}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.
%
Last but not least, we have an example of the fact,
highlighted in Kov{\'{a}}cs' original paper, that static
datatypes do not need to have a counterpart at runtime:
pairs are only available in the static layer and all traces
of pairs will have completely disappeared after staging.

\subsection{Contexts and Variables}

In order to closely match our usual mathematical notations,
contexts are defined as left-nested lists of types.

\ExecuteMetaData[TwoTT.tex]{context}

Contexts can either be empty (written \AIC{ε})
or take an existing context \AB{Γ} and extend it on the
right with a newly bound variable of type \AB{σ}
(written \AB{Γ} \AIC{-,} \AB{σ}).
Note that the stage of the newly bound variable is
existentially quantified.

Once we have contexts, we can formalise what it means
for a variable of type \AB{σ} to be present in context \AB{Γ}.
This is a standard definition corresponding to a scoped-and-typed
variant of de Bruijn index~\cite{de1972lambda}.

\ExecuteMetaData[TwoTT.tex]{var}

Here we used notations meant to once again mimick inference
rules~\cite{DBLP:conf/cpp/Allais0MM17}.
\todo{Add inference rules}

\subsection{Intrinsically Scoped and Typed Syntax}

\ExecuteMetaData[TwoTT.tex]{term}

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an \AF{eval}uation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.

\ExecuteMetaData[TwoTT.tex]{evaldecl}

We start with the model construction describing precisely
what these values ought to be.

\subsection{Model Construction}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as terms
guaranteed not to contain any static subterm.

\ExecuteMetaData[TwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation
construction~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{modelstadecl}
\ExecuteMetaData[TwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

\ExecuteMetaData[TwoTT.tex]{thin}

\ExecuteMetaData[TwoTT.tex]{kripke}

\ExecuteMetaData[TwoTT.tex]{thinrefl}

\ExecuteMetaData[TwoTT.tex]{kripkeapp}


\subsection{Evaluation}

\ExecuteMetaData[TwoTT.tex]{zero}
\ExecuteMetaData[TwoTT.tex]{succ}
\ExecuteMetaData[TwoTT.tex]{app}
\ExecuteMetaData[TwoTT.tex]{lam}


\ExecuteMetaData[TwoTT.tex]{extend}

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{evaldecl}
\ExecuteMetaData[TwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{bodydecl}
\ExecuteMetaData[TwoTT.tex]{body}
\end{AgdaSuppressSpace}


\section{Future Work}

\cite{DBLP:journals/lisp/Coquand02}

\newpage
\printbibliography

\end{document}
