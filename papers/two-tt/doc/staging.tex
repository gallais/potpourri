\documentclass{article}

%%% Remark environment
\usepackage{amsthm}
\newtheorem*{remark}{Remark}

%%%% Agda code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{agda}
\input{unicode}
\usepackage{catchfilebetweentags}
\input{robust-catch}
% do not indent code blocks
\setlength\mathindent{0em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\setuptodonotes{inline}

\input{commands}

%%% References
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[style=alphabetic]{biblatex}
\bibliography{staging.bib}

%%% Inference rules
\usepackage{mathpartir}

\title{Scoped and Typed Staging by Evaluation}
\author{Guillaume Allais}

\begin{document}

\maketitle

\section{Introduction}

This paper gives an intrinsically scoped-and-typed
treatment of a simply typed version of the staged compilation
with two-level type theory introduced by
Kov{\'{a}}cs~\cite{DBLP:journals/pacmpl/Kovacs22}.
%
We use Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do)
and mobilise standard formalisation
techniques~\cite{DBLP:journals/lisp/Coquand02, DBLP:journals/jar/BentonHKM12}
and structures extensively studied by Allais, Chapman,
McBride, and McKinna (from now on refered to as ACMM)~\cite{DBLP:conf/cpp/Allais0MM17}.

Starting from a language with a static and a dynamic layer,
we perform a type-directed model construction
and define an evaluation function turning terms
into their semantical counterpart.
%
As a corollary, we obtain a staging function that
fully evaluates all of the static subterms and returns
purely dynamic ones.

As already observed by Kov{\'{a}}cs, this model construction
is analogous to the one used for normalisation by evaluation,
hence the title of this paper.

\section{A Primer on Intrinsically Typed λ-Calculi}\label{sec:intrinsictyping}

Let us start with a quick primer on intrinsically typed λ-calculi
defined in a dependently typed host language. The interested reader
can refer to ACMM~\cite{DBLP:conf/cpp/Allais0MM17} for a more in-depth
presentation of this approach.

\subsection{Object Types and Contexts}

We first give a sum type of object types:
\AIC{`ℕ} that stands for the base type of natural numbers,
and (\AB{A} \AIC{`⇒} \AB{B}) for the type of functions from
\AB{A} to \AB{B}.

\ExecuteMetaData[STLC.tex]{type}

\begin{remark}[Syntax Highlighting]
  All the code in this paper is semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}.
\end{remark}

We extensively use Agda's \AK{variable} mechanism: all of
the seemingly unbound names will in fact be automatically
quantified over in a prenex position provided that they
have been declared beforehand.
%
The following block for instance announces that from now
on unbound \AB{A}s and \AB{B}s stand for implicitly bound
\AD{Type} variables.

\ExecuteMetaData[STLC.tex]{typevariables}

Next, we form contexts as left-nested lists of types using
constructor names similar to the ones typically used in
inference rules.
Contexts may be the empty context \AIC{ε}
or a compound context (\AB{Γ} \AIC{,} \AB{A}) obtained
by extending an existing context \AB{Γ} on the right
with a newly bound (nameless) variable of type \AB{A}.

\ExecuteMetaData[STLC.tex]{context}

\subsection{Manipulating Indexed Types}

In this paper we are going to conform to the convention
of only mentioning context \emph{extensions} when
presenting judgements.
%
That is to say we will write the application and
λ-abstraction rules as they are in the right column
rather than the left one that make the ambient context Γ
explicit.

\noindent
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{Γ ⊢ f : A → B \and Γ ⊢ t : A}{Γ ⊢ f \, t : B} \and
    \inferrule{Γ, x : A ⊢ b : B}{Γ ⊢ λx.b : A → B}
  \end{mathpar}
\end{minipage}\hfill
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{f : A → B \and t : A}{f \, t : B} \and
    \inferrule{x : A ⊢ b : B}{λx.b : A → B}
  \end{mathpar}
\end{minipage}

To do so, we need to introduce a small set of combinators
to manipulate indexed definitions. These are standard and
already present in Agda's standard library.
%
First, \AF{∀[\_]} universally quantifies over its argument's index;
it is meant to be used to surround a complex expression built
up using the other combinators.
%
Second, the suggestively named \AF{\_⊢\_} allows us to modify
the index; it will be useful to extend a context with freshly
bound variables.
%
Third, we can form index-respecting function spaces using \AF{\_⇒\_}.
%
Finally, the pointwise lifting of pairing is called \AF{\_∩\_};
it will only come into play in \Cref{sec:stagingmodel}.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[STLC.tex]{forall}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{update}
\end{minipage}

\noindent
\begin{minipage}{.4\textwidth}
\ExecuteMetaData[STLC.tex]{arrow}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
\ExecuteMetaData[STLC.tex]{product}
\end{minipage}

\subsection{Intrinsically Typed Variables}

Our first inductive family formalises what it means for a variable of type
\AB{A} to be present in context \AB{Γ}. We present it side by side
with the corresponding inference rules for the typing judgement
for variables denoted ($\cdot :_v \cdot$).
%
The first constructor (\AIC{here}) states that in a non-empty context
where the most local variable has type \AB{A} we can indeed obtain a
variable of type \AB{A}.
%
The second one (\AIC{there}) states that if a variable of type \AB{A}
is present in a context then it also is present in the same context
extended with a freshly bound variable of type \AB{B}.

\noindent
\begin{minipage}{.5\textwidth}
\ExecuteMetaData[STLC.tex]{var}
\end{minipage}\hfill
\begin{minipage}{.4\textwidth}
\begin{mathpar}
  \inferrule{ }{x : A ⊢ x :_v A} \and
  \inferrule{x :_v A}{y : B ⊢ x :_v A}
\end{mathpar}
\end{minipage}

This is a standard definition
corresponding to a scoped-and-typed variant of de Bruijn
indices~\cite{de1972lambda}.

\subsection{Intrinsically Typed Terms}

We are now ready to give the type of intrinsically typed terms.
It is an inductive family~\cite{DBLP:journals/fac/Dybjer94}
indexed over a type and a context.

\ExecuteMetaData[STLC.tex]{termdecl}

We will introduce constructors in turn, each accompanied by its
counterpart as an inference rule.
%
We start with the variable rule: a variable of type \AB{A} in
context forms a valid term of type \AB{A}.
%
As you can see below, we use a line lexed as a comment (\AC{---})
to suggestively typeset the constructor's type like the
corresponding rule.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termvar}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x :_v A}{x : A}
\end{mathpar}
\end{minipage}

Next with have the constructor for applications. It states that
by combining a term whose type is a function type from \AB{A} to \AB{B}
and a term of type \AB{A}, we obtain a term of type \AB{B}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termapp}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{f : A → B \and t : A}{f \, t : B}
\end{mathpar}
\end{minipage}

Last but not least, the rule for λ-abstraction is the only rule
with a premise mentioning a context extension. It states that
we can build a term for a function from \AB{A} to \AB{B} by
building the function's body of type \AB{B} in a context extended
by a freshly bound variable of type \AB{A}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termlam}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x : A ⊢ b : B}{λx.b : A → B}
\end{mathpar}
\end{minipage}


Putting it all together, we obtain the following inductive family.

\begin{AgdaAlign}
\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{term}
\end{AgdaSuppressSpace}
\end{AgdaAlign}

\section{An Intrinsically Typed 2 Level Type Theory}
\todo{start with examples}


\subsection{Stages and Types}

Our notion of types is going to be explicitly indexed by the
stage they live in, and so we begin by defining a sum
type \AD{Stage} with two constructors: \AIC{static},
and \AIC{dynamic}.

\ExecuteMetaData[TwoTT.tex]{stage}

We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[TwoTT.tex]{types}

We have both static and dynamic natural numbers,
hence the unconstrained index \AB{st} for the
constructor \AIC{`ℕ}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.
%
Last but not least, we have an example of the fact,
highlighted in Kov{\'{a}}cs' original paper, that static
datatypes do not need to have a counterpart at runtime:
pairs are only available in the static layer and all traces
of pairs will have completely disappeared after staging.

\subsection{Intrinsically Scoped and Typed Syntax}

We skip over the definition of contexts and variables: they
are essentially the same as the ones we gave in \Cref{sec:intrinsictyping}.

\ExecuteMetaData[TwoTT.tex]{term}

We introduce two aliases.
%
First, \AF{Source} for the terms users can write and that
may that can mention quotes, splices, pairs, and projections.
%
Second, \AF{Staged} for our target language where all the
static subterms have been evaluated away.

\ExecuteMetaData[TwoTT.tex]{termaliases}

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an \AF{eval}uation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.

\ExecuteMetaData[TwoTT.tex]{evaldecl}

As a direct corollary we will obtain a staging function
that takes a closed dynamic term and gets rid of all of
the quotes, splices, and pairs and projections by fully
evaluating all of its static parts.

\ExecuteMetaData[TwoTT.tex]{stagedecl}

We start with the model construction describing precisely
the type of values.

\subsection{Model Construction}\label{sec:stagingmodel}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as terms
guaranteed not to contain any static subterm.

\ExecuteMetaData[TwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation
construction~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{modelstadecl}
\ExecuteMetaData[TwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

Static values of type \AIC{`ℕ} are constant natural numbers;
those of type (\AIC{`⇑} \AB{A}) are dynamic values of type \AB{A}
i.e. staged terms of type \AB{A};
functions from \AB{A} to \AB{B} are interpreted using Kripke function
spaces from static values of type \AB{A} to static values of type \AB{B};
and finally static pairs are pairs of static values.

\ExecuteMetaData[TwoTT.tex]{thin}

\ExecuteMetaData[TwoTT.tex]{kripke}

\ExecuteMetaData[TwoTT.tex]{thinrefl}

\ExecuteMetaData[TwoTT.tex]{kripkeapp}


\subsection{Evaluation}

We can explain what the meaning of each term constructor is.
In every instance we will proceed by case analysis on the
stage the meaning is being used at.


The term constructor \AIC{`zero} is either interpreted by
the natural number \AN{0} or by the term constructor itself
depending on whether it is used in a static or dynamic manner.

\ExecuteMetaData[TwoTT.tex]{zero}

Similarly \AIC{`succ} is interpreted either as (\AN{1} \AF{+}\AS{\_})
if it used in a static manner or by the term constructor itself
for dynamic uses.

\ExecuteMetaData[TwoTT.tex]{succ}

Application is interpreted as the semantic application defined
for Kripke function spaces in the static case, and the syntactic
\AIC{`app} constructor in the dynamic one.

\ExecuteMetaData[TwoTT.tex]{app}



\ExecuteMetaData[TwoTT.tex]{lam}


\ExecuteMetaData[TwoTT.tex]{extend}

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{evaldecl}
\ExecuteMetaData[TwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[TwoTT.tex]{bodydecl}
\ExecuteMetaData[TwoTT.tex]{body}
\end{AgdaSuppressSpace}



\section{Future Work}

\cite{DBLP:journals/lisp/Coquand02}

\newpage
\printbibliography

\end{document}
