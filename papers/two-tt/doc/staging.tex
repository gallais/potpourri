\documentclass{article}

%%% Remark environment
\usepackage{amsthm}
\newtheorem*{remark}{Agda-ism}

%%%% Agda code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{agda}
\input{unicode}
\usepackage{catchfilebetweentags}
\input{robust-catch}
% do not indent code blocks
\setlength\mathindent{0em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\setuptodonotes{inline}

\input{commands}

%%% Tikz
\usepackage{tikz}
\usepackage{circuitikz}
\ctikzset{logic ports=ieee}
%%\usepackage{calc}

%%% Toggle
\newtoggle{BLIND}
\togglefalse{BLIND}

%%% References
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[style=alphabetic]{biblatex}
\bibliography{staging.bib}

%%% Inference rules
\usepackage{mathpartir}

\title{Scoped and Typed Staging by Evaluation}
\iftoggle{BLIND}{
  \author{ANONYMOUS}
}{
  \author{Guillaume Allais}
}

\begin{document}

\maketitle

\section{Introduction}

This paper gives an intrinsically scoped-and-typed
treatment of a simply typed version of the staged compilation
with two-level type theory introduced by
Kov{\'{a}}cs~\cite{DBLP:journals/pacmpl/Kovacs22}.
%
We use Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do)
and mobilise standard formalisation
techniques~\cite{DBLP:journals/lisp/Coquand02, DBLP:journals/jar/BentonHKM12}
and structures extensively studied by Allais, Chapman,
McBride, and McKinna (from now on refered to as ACMM)~\cite{DBLP:conf/cpp/Allais0MM17}.

Starting from a language with a static and a dynamic layer,
we perform a type-directed model construction
and define an evaluation function turning terms
into their semantical counterpart.
%
As a corollary, we obtain a staging function that
fully evaluates all of the static subterms and returns
purely dynamic ones.
%
As already observed by Kov{\'{a}}cs, this model construction
is analogous to the one used for normalisation by evaluation,
hence the title of this paper.

\todo{start with examples}

\section{A Primer on Intrinsically Typed λ-Calculi}\label{sec:intrinsictyping}

Let us start with a quick primer on intrinsically typed λ-calculi
defined in a dependently typed host language. The interested reader
can refer to ACMM~\cite{DBLP:conf/cpp/Allais0MM17} for a more in-depth
presentation of this approach.

\subsection{Object Types and Contexts}

We first give an inductive definition of object types.
We call it \AF{Type} and its own type is \AF{Set},
the type of all small types in Agda.
It has two constructors presented in generalised algebraic
datatype fashion.
We use \AIC{`α} as our base type,
and (\AB{A} \AIC{`⇒} \AB{B}) is the type of functions from
\AB{A} to \AB{B}.

\ExecuteMetaData[STLC.tex]{type}

\begin{remark}[Syntax Highlighting]
  All of the code snippets in this paper are semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}, and comments are \AC{brown}.
\end{remark}

\begin{remark}[Implicit Prenex Polymorphism]
  We extensively use Agda's \AK{variable} mechanism: all of
  the seemingly unbound names will in fact have been automatically
  quantified over in a prenex position provided that they
  have been declared beforehand.
\end{remark}

The following block for instance announces that from now
on unbound \AB{A}s, \AB{B}s, and \AB{C}s stand for implicitly bound
\AD{Type} variables.

\ExecuteMetaData[STLC.tex]{typevariables}

Next, we form contexts as left-nested lists of types using
constructor names similar to the ones typically used in
type judgments.
Contexts may be the empty context \AIC{ε}
or a compound context (\AB{Γ} \AIC{,} \AB{A}) obtained
by extending an existing context \AB{Γ} on the right
with a newly bound (nameless) variable of type \AB{A}.

\ExecuteMetaData[STLC.tex]{context}

\subsection{Manipulating Indexed Types}

In this paper we are going to conform to the convention
of only mentioning context \emph{extensions} when
presenting judgements.
%
That is to say we will write the application and
λ-abstraction rules as they are in the right column
rather than the left one where the ambient context Γ
is explicitly threaded.

\noindent
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{Γ ⊢ f : A → B \and Γ ⊢ t : A}{Γ ⊢ f \, t : B} \and
    \inferrule{Γ, x : A ⊢ b : B}{Γ ⊢ λx.b : A → B}
  \end{mathpar}
\end{minipage}\hfill
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{f : A → B \and t : A}{f \, t : B} \and
    \inferrule{x : A ⊢ b : B}{λx.b : A → B}
  \end{mathpar}
\end{minipage}

To do so, we need to introduce a small set of combinators
to manipulate indexed definitions. These are commonplace
and already present in Agda's standard library.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[STLC.tex]{forall}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{update}
\end{minipage}

First, \AF{∀[\_]} universally quantifies over its argument's index;
it is meant to be used to surround a complex expression built
up using the other combinators.
%
Second, the suggestively named \AF{\_⊢\_} allows us to modify
the index; it will be useful to extend a context with freshly
bound variables.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[STLC.tex]{arrow}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{product}
\end{minipage}

Third, we can form index-respecting function spaces using \AF{\_⇒\_}.
%
Finally, the pointwise lifting of pairing is called \AF{\_∩\_};
it will only come into play in \Cref{sec:stagingmodelprod}.

We include below an artificial example of a type written using
the combinators together with its full expansion using explicit
context-passing.

\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{swaptype}
  \ExecuteMetaData[STLC.tex]{swaptypenormalised}
\end{AgdaSuppressSpace}

\subsection{Intrinsically Typed Variables}

Our first inductive family~\cite{DBLP:journals/fac/Dybjer94} formalises
what it means for a variable of type \AB{A} to be present in context \AB{Γ}.
It is indexed over said type and context.
We present it side by side
with the corresponding inference rules for the typing judgement
for variables denoted ($\cdot :_v \cdot$).
%
The first constructor (\AIC{here}) states that in a non-empty context
where the most local variable has type \AB{A} we can indeed obtain a
variable of type \AB{A}.
%
The second one (\AIC{there}) states that if a variable of type \AB{A}
is present in a context then it also is present in the same context
extended with a freshly bound variable of type \AB{B}.

\noindent
\begin{minipage}{.5\textwidth}
\ExecuteMetaData[STLC.tex]{var}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{mathpar}
  \inferrule{ }{x : A ⊢ x :_v A} \and
  \inferrule{x :_v A}{y : B ⊢ x :_v A}
\end{mathpar}
\end{minipage}

This is a standard definition
corresponding to a scoped-and-typed variant of de Bruijn
indices~\cite{de1972lambda}:
\AIC{here} corresponds to zero, and \AIC{there} to successor.

\subsection{Intrinsically Typed Terms}

We are now ready to give the type of intrinsically typed terms.
It is once again an inductive family indexed over a type and a
context; its declaration is as follows.

\ExecuteMetaData[STLC.tex]{termdecl}

We will introduce constructors in turn, each paralleled by its
counterpart as an inference rule.
%
We start with the variable rule: a variable of type \AB{A}
forms a valid term of type \AB{A}.
%
As you can see below, we use a line lexed as a comment (\AC{---})
to suggestively typeset the constructor's type like the
corresponding rule.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termvar}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x :_v A}{x : A}
\end{mathpar}
\end{minipage}

Next we have the constructor for applications. It states that
by combining a term whose type is a function type from \AB{A} to \AB{B}
and a term of type \AB{A}, we obtain a term of type \AB{B}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termapp}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{f : A → B \and t : A}{f \, t : B}
\end{mathpar}
\end{minipage}

Last but not least, the rule for λ-abstraction is the only rule
with a premise mentioning a context extension. It states that
we can build a term for a function from \AB{A} to \AB{B} by
building the function's body of type \AB{B} in a context extended
by a freshly bound variable of type \AB{A}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termlam}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x : A ⊢ b : B}{λx.b : A → B}
\end{mathpar}
\end{minipage}

Putting it all together, we obtain the following inductive family.

\begin{AgdaAlign}
\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{term}
\end{AgdaSuppressSpace}
\end{AgdaAlign}

This gives us the intrinsically scoped-and-typed syntax for
the simply typed lambda calculus.
And we give our first example: the identity function ($λ.0$ in de Bruijn notation).

\ExecuteMetaData[STLC.tex]{id}


As any well behaved syntax should,
it is stable under weakening as we are going to see shortly.

\subsection{Weakening}

Following Altenkirch, Hofmann, and Streicher~\cite{DBLP:conf/ctcs/AltenkirchHS95}
we start by defining the category of weakenings with contexts
as objects and the following inductive family as morphims.

\ExecuteMetaData[STLC.tex]{ope}

This relation on contexts, also known as order-preserving embeddings in the
literature, is a first order description of order-preserving
injections:
\AIC{done} is the trivial injection of the empty context into
itself;
\AIC{keep} extends an existing injection into one that preserves
the most local variable;
and \AIC{drop} records that the most local variable of the target
context does not have a pre-image via the injection.

We can define identity and composition of these morphisms (we leave
the definitions out and invite the interested reader to look
at the code in the accompanying material).

\noindent
\begin{minipage}{.3\textwidth}
  \ExecuteMetaData[STLC.tex]{lerefl}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{letrans}
\end{minipage}

These order-preserving embeddings all have an action on suitably
well behaved scoped families. We will call these actions weakening
principles, and introduce the following type synonym to describe them.

\ExecuteMetaData[STLC.tex]{weaken}

The action on variables is given
by the following \AF{weak-Var} definition. It is defined by
induction over the renaming and case analysis on the de Bruijn
index if the most local variable happens to be in both contexts.

\ExecuteMetaData[STLC.tex]{weakVar}

The action on terms is purely structural, with the caveat that
the weakening needs to be amended when going under a binder: the
most recently bound variable is present in both the source and
target contexts and so we use \AIC{keep} to mark it as retained.

\ExecuteMetaData[STLC.tex]{weakTerm}

Using these results, we can define function composition
as a pseudo constructor: provided $g$ and $f$, we form
$λx.g\,(f\, x)$ i.e. we use $g$ and $f$ in a context extended
with $x$ hence the need for weakening.

\label{def:composition}
\ExecuteMetaData[STLC.tex]{composition}

\begin{remark}[Lexing of Identifiers]
  Ignoring details about reserved characters for now: any
  space-free string of unicode characters is considered a
  single identifier.
  Correspondingly, in the example above \AB{Γ≤Γ,A} is a single
  identifier named like this to document for the human reader
  what its type looks like.
\end{remark}

\subsection{Normalisation by Evaluation}

It is now time to define an evaluation function for this syntax.
By the end of this section, we will have a function \AF{eval}
turning terms into values,
provided that we have an environment assigning values
to each of the term's free variables. It will have the following type.

\ExecuteMetaData[STLC.tex]{evaldecl}

\subsubsection{Kripke Function Spaces}

This whole process is based on Kripke semantics for intuitionistic
logic~\cite{DBLP:journals/apal/MitchellM91}.
As a consequence one of the central concepts is closure under future
worlds, here context extensions.
This idea is captured by the definition of the \AR{□} record: we
can inhabit (\AR{□} \AB{A} \AB{Γ}) whenever for any extension
\AB{Δ} of \AB{Γ} we are able to construct an (\AB{A} \AB{Δ}).

\ExecuteMetaData[STLC.tex]{box}

For more information on \AR{□} and its properties, the interested
reader can consult Allais, Atkey, Chapman, McBride, and
McKinna~\cite[Section~3.1]{DBLP:journals/jfp/AllaisACMM21}.
%
We will only use the fact that it is a comonad, that is to say that
we can define \AF{extract} and \AF{duplicate} thanks to
the fact that the embedding relation is a preorder.

\ExecuteMetaData[STLC.tex]{extract}
\ExecuteMetaData[STLC.tex]{duplicate}

Kripke function spaces then correspond to functions inside a box,
hence the following definition.

\ExecuteMetaData[STLC.tex]{kripke}

The comonadic structure of \AF{□} additionally ensures we can define
semantic application (\AF{\_\$\$\_}) and weakening of Kripke function
spaces.

\noindent
\begin{minipage}{0.45\textwidth}
  \ExecuteMetaData[STLC.tex]{semapp}
\end{minipage}\hfill
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[STLC.tex]{weakKripke}
\end{minipage}

Finally, we introduce a notation to hide away \AR{□}-related
notions when building \AF{Kripke} functions.
%
After the following declarations we can simply write
\AIC{λλ[} \AB{σ} \AIC{,} \AB{v} \AIC{]} \AB{b} to implement a function of type
(\AF{Kripke} \AB{A} \AB{B} \AB{Γ}).

\ExecuteMetaData[STLC.tex]{mkbox}

We now have all of the ingredients to perform the model
construction allowing us to implement a normaliser.

\subsubsection{Model Construction}

This step follows standard techniques for normalisation
by evaluation~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}.
The family of values is defined by induction on the value's
type.
%
Values of a base type are neutral terms (this is not enforced here and
we are happy to simply reuse \AF{Term}) while values of a function type
are Kripke function spaces between values of the domain and values of
the codomain.

\ExecuteMetaData[STLC.tex]{value}

It is easy to prove that values can be weakened given that they are
defined in terms of families already known to be amenable to weakenings.

\ExecuteMetaData[STLC.tex]{weakValue}

Environments are functions associating a \AF{Value}
to each \AF{Var}iable in scope.

\ExecuteMetaData[STLC.tex]{env}

Environments will mostly be passed around except when they are pushed
under a binder, interpreted as a Kripke function space.
%
In this case, the environment will have to be extended with the newly
provided value while its existing content will have to be transported
into the bigger context.
%
The \AF{extend} definition combines these two operations into a single
one. It is defined in copattern style~\cite{DBLP:conf/popl/AbelPTS13}:
{\AS{.}\ARF{runBox}} builds a box while {\AS{.}\ARF{lookup}} builds the
returned environment. The definition proceeds by case analysis on the
variable to be mapped to a value: if it is the newly bound one, we
immediately return the value we just obtained, and otherwise we look
up the associated value in the old environment and use \AB{σ} to
appropriately weaken it.

\ExecuteMetaData[STLC.tex]{extend}

The evaluation function maps terms to values provided that
an environment assigns a value to every free variable in scope.
It is defined by induction on the term and maps every construct
to its semantical counterpart: variables become environment lookups,
application become Kripke applications, and λ-abstractions become
Kripke functions.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[STLC.tex]{eval}
\end{AgdaSuppressSpace}

\section{Minimal Intrinsically Typed Two Level Type Theory}

We start with the smallest two level calculus we can possibly define
by extending the simply typed λ-calculus as defined in the previous
section with quotes and splices.

This will enable us to write and stage simple programs such as the following.

\ExecuteMetaData[BasicTwoTT.tex]{testid01}

The three-place relation (\AB{A} \AF{∋} \AB{s} \AF{↝} \AB{t}) states
that staging a term \AB{s} at type \AB{A} yields the term \AB{t}.
%
Here, \AF{`idᵈ} is a dynamic identity function
while \AF{`idˢ} is a static one,
\AIC{`⟨\_⟩} quotes a static term inside a dynamic one,
and \AIC{`∼\_} splices a dynamic term in a static one.
%
Correspondingly, staging will partially evaluate the call to
\AF{`idˢ} as well as all the quotes and splices while leaving
the rest of the term intact.
%
Hence the result: the call to the static identity function has
fully reduced but the call to the dynamic one has been preserved.


\subsection{Phases, Stages, and Types}

We start by defining a sum type of phases denoting whether
we are currently writing \AIC{source} code or inspecting
\AIC{staged} code that has already been partially evaluated.

\ExecuteMetaData[BasicTwoTT.tex]{phase}

Additionally, our notion of types is going to be explicitly
indexed by the stage they live in. These stages are indexed
over the phase they are allowed to appear in.
%
The \AIC{static} stage is only available in the \AIC{source}
phase: once code has been staged, all of its static parts will
be gone.
%
The \AIC{dynamic} stage however will be available in both
phases, hence the unconstrained index \AB{ph}.

\ExecuteMetaData[BasicTwoTT.tex]{stage}

We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[BasicTwoTT.tex]{types}

We have both static and dynamic terms of base type,
hence the unconstrained indices \AB{ph} and \AB{st}
for the constructor \AIC{`α}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime. This is only available in the
\AIC{source} phase.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.

Purely dynamic types in the source phase have a direct
counterpart in the staged one. We demonstrate this by
implementing the following \AF{asStaged} function.

\ExecuteMetaData[BasicTwoTT.tex]{asStaged}

It is essentially the identity function except for the
fact that its domain and codomain have different indices.

\subsection{Intrinsically Scoped and Typed Syntax}

We skip over the definition of contexts and variables: they
are essentially the same as the ones we gave in \Cref{sec:intrinsictyping}.

Our type of term is indexed by a phase, a stage, a type
at that stage, and a context.

\ExecuteMetaData[BasicTwoTT.tex]{termdecl}

The first constructors are familiar: they are exactly the ones
seen in the previous section. These constructs are available
at both levels and both before and after staging hence the fact
that the state and phase indices are polymorphic here.

\ExecuteMetaData[BasicTwoTT.tex]{termstlc}

Next we have the constructs specific to the two level calculus:
quotes (\AIC{`⟨\_⟩}) let users insert dynamic terms into static
expressions while splices (\AIC{`∼\_}) allow static terms to
be inserted in dynamic ones.
%
Staging will, by definition, eliminate these and so their phase
index is constrained to be \AIC{source}.

\ExecuteMetaData[BasicTwoTT.tex]{termtwolevel}


Putting it all together, we obtain the following inductive
family representing a minimal intrinsically typed two-level
calculus.

\begin{AgdaAlign}
  \begin{AgdaSuppressSpace}
    \ExecuteMetaData[BasicTwoTT.tex]{term}
  \end{AgdaSuppressSpace}
\end{AgdaAlign}

We can readily write examples such as the following definitions
of a purely dynamic and a purely static identity function. The
dynamic function will survive staging even if it is applied to a
dynamic argument while the static one can only exist in the
source phase and will be fully evaluated during staging.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{iddyn}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{idsta}
\end{minipage}

Now that we have a syntax, we can start building the machinery
that will actually perform its partial evaluation.

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an \AF{eval}uation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.

\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}

As a corollary we will obtain a staging function
that takes a closed dynamic term and gets rid of all of
the quotes and splices by fully
evaluating all of its static parts.

\ExecuteMetaData[BasicTwoTT.tex]{stagedecl}

We start with the model construction describing precisely
the type of values.

\subsection{Model Construction}\label{sec:stagingmodel}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as staged terms
i.e. terms guaranteed not to contain any static subterm.

\ExecuteMetaData[BasicTwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation construction
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{modelstadecl}
\ExecuteMetaData[BasicTwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

There are no static values of type \AIC{`α} as this base type does
not have any associated constructors and so we return the empty type \AD{⊥};
values of type (\AIC{`⇑} \AB{A}) are dynamic values of type \AB{A}
i.e. staged terms of type \AB{A};
functions from \AB{A} to \AB{B} are interpreted using Kripke function
spaces from static values of type \AB{A} to static values of type \AB{B}.

\ExecuteMetaData[BasicTwoTT.tex]{thin}

\ExecuteMetaData[BasicTwoTT.tex]{kripke}

\ExecuteMetaData[BasicTwoTT.tex]{thinrefl}

\ExecuteMetaData[BasicTwoTT.tex]{kripkeapp}
\ExecuteMetaData[BasicTwoTT.tex]{kripkelam}


\subsection{Evaluation}

We can explain what the meaning of each term constructor is.
In every instance we will proceed by case analysis on the
stage the meaning is being used at.


Application is interpreted as the semantic application defined
for Kripke function spaces in the static case, and the syntactic
\AIC{`app} constructor in the dynamic one.

\ExecuteMetaData[BasicTwoTT.tex]{app}


\ExecuteMetaData[BasicTwoTT.tex]{lam}


\ExecuteMetaData[BasicTwoTT.tex]{extend}

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}
\ExecuteMetaData[BasicTwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{bodydecl}
\ExecuteMetaData[BasicTwoTT.tex]{body}
\end{AgdaSuppressSpace}

We obtain the \AF{stage} function by calling \AF{eval} with an
empty environment.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{stagefun}
\end{AgdaSuppressSpace}


\section{A More Practical Two Level Calculus}

We are now going to extend the minimal calculus we used so far to
show a more realistic example of a two level calculus.

First we are going to add natural numbers and their eliminator.
These will be available at both stages and we will see how we
can transfer a static natural number to the dynamic phase by
defining a static \AF{`reify} term.

Second, based on Kov{\'{a}}cs' observation that the static and
dynamic language do not need to have exactly the same features,
we are going to add a type of static pairs.
%
These pairs and their projections can be used in arbitrary static
code but will be guaranteed to be evaluated away during staging.
%
We will demonstrate this by giving a static term \AF{`fib}
implementing a standard linear (ignoring the cost of addition)
algorithm for the Fibonacci function.
%
This will allow us to obtain e.g.

\ExecuteMetaData[TwoTT.tex]{testfib}

\noindent where \AF{fromℕ} is a helper function turning Agda
literals into \AF{Term}s built using \AIC{`zero} and \AIC{`succ}.

\subsection{Adding natural numbers}

Our first extension adds the inductive type of Peano-style natural numbers,
its two constructors, and the appropriate eliminator for it.

\subsubsection{Types and Terms}

First we extend the definition of \AD{Type} with a new constructor
\AIC{`ℕ}. Natural numbers will be present at both stages and so we
allow the index to be polymorphic.

\ExecuteMetaData[TwoTT.tex]{typesnat}

We then add \AD{Term} constructors for the two Peano-style
constructors (\AIC{`zero} and \AIC{`succ}) as well as an
eliminator (\AIC{`iter}) which turns a natural number into
its Church encoding~\cite[Chapter 3]{church1941calculi}.

\ExecuteMetaData[TwoTT.tex]{termnat}

Our first program example is the function \AF{`reify} that
turns its static natural number argument into a dynamic
encoding.

\ExecuteMetaData[TwoTT.tex]{reify}

We can also naturally define addition as iterated calls to
\AIC{`succ}.

\label{def:add}
\ExecuteMetaData[TwoTT.tex]{add}

\subsubsection{Staging by Evaluation}

Static values of type \AIC{`ℕ} are constant natural numbers.

\ExecuteMetaData[TwoTT.tex]{modelnat}

The term constructor \AIC{`zero} is either interpreted by
the natural number \AN{0} or by the term constructor itself
depending on whether it is used in a static or dynamic manner.

\ExecuteMetaData[TwoTT.tex]{zero}

Similarly \AIC{`succ} is interpreted either as (\AN{1} \AF{+}\AS{\_})
if it used in a static manner or by the term constructor itself
for dynamic uses.

\ExecuteMetaData[TwoTT.tex]{succ}

The meaning of \AIC{`iter} in the static layer is defined in
terms of the \AF{iterate} function defined by pattern-matching
in the host language and turning a natural number into its
Church encoding.

\ExecuteMetaData[TwoTT.tex]{iter}

\subsection{Adding static pairs}\label{sec:stagingmodelprod}

We now have an example of the fact, highlighted in Kov{\'{a}}cs'
original paper, that static datatypes do not need to have a
counterpart at runtime: pairs are only available in the static
layer and all traces of pairs and their projections will have
completely disappeared after staging.

\subsubsection{Types and Terms}

\ExecuteMetaData[TwoTT.tex]{typesprod}

\ExecuteMetaData[TwoTT.tex]{termprod}

\ExecuteMetaData[TwoTT.tex]{fib}

using \AF{\_`∘\_} defined in~\Cref{def:composition},
and \AF{`add} defined in~\Cref{def:add}.

\subsubsection{Staging by Evaluation}

Static pairs are pairs of static values.

\ExecuteMetaData[TwoTT.tex]{modelprod}


\section{Application: Circuit Generation}

This section's content is inspired by Quipper, a functional
programming language to describe quantum computations
introduced by Green, Lumsdaine, Ross, Selinger, and
Valiron~\cite{DBLP:conf/rc/GreenLRSV13} and related
formal treatments such as Rennela and Staton's categorical
models~\cite{DBLP:journals/lmcs/RennelaS19}.
%
This strand of research gives us a good example of a setting in which
we have two very distinct layers: a static layer with a
full-fledged functional language, and a dynamic layer of
quantum circuits obtained by partially evaluating the source.

In our proof of concept, we focus on a minimal language of
classical circuits inspired by Π-ware a formal hardware
description and verification language proposed by
Flor, Swierstra, and Sijsling~\cite{DBLP:conf/types/FlorSS15}.
%
This allows us to focus on the two-level aspect instead of
having to deal with linearity and unitary operators which are
specific to the Quantum aspect.

\subsection{Types and Terms}

Our definition of types should now be mostly unsurprising.
We have function spaces (this time confined to the static
layer), a lifting construct allowing the embedding of
dynamic types in the static layer at the source stage,
and finally a type of circuits characterised by their input
and output arities, both represented by a natural number in
the host language.

\ExecuteMetaData[MetaCircuit.tex]{type}

Next, we extend the basic simply typed lambda calculus with
quotes and splices with term constructors for circuit descriptions.
They will all belong to the dynamic stage.
%
Our first constructor gives us the universal nand gate.
Its type records the fact it takes two inputs and returns
a single output.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitnand}

Next, we have a constructor for the parallel composition
of existing circuits. The input and output arities of the
resulting circuit are obtained by adding up the respective
input and output arities of each of the components.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitpar}

We can also compose circuits sequentially, provided
that the output arity of the first circuit matches
the input arity of the second.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitseq}

Finally, we follow the Π-ware~\cite{DBLP:conf/types/FlorSS15}
approach and offer a general rewiring component.
A `mix' of $i$ inputs returning $o$ outputs is defined by
a vector (i.e. a list of known length) of size $o$
containing finite numbers between $0$ and $i$
corresponding to the input the output is connected to.
%
This allows arbitrary duplications and deletions
of inputs.

\todo{Explain vec, fin; give example with diagram}

\ExecuteMetaData[MetaCircuit.tex]{termcircuitmix}

Typical examples include
\AF{`id$_2$} (the identity circuit on two inputs),
\AF{`swap} (the circuit connecting its first input to its second output and vice-versa),
and \AF{`dup} (the circuit duplicating its single input).
We present them below together with the corresponding wiring diagrams.

\noindent
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{id2}
\end{minipage}\hfill
\begin{minipage}{.25\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,0)  circle[radius=1.5pt] node { };
    \draw[fill] (0,.5) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,0)  to [out=0,in=180] (.95,0);
    \draw[-] (0,.5) to [out=0,in=180] (.95,.5);
  \end{tikzpicture}
\end{minipage}

\noindent
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{swap}
\end{minipage}\hfill
\begin{minipage}{.25\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,0)  circle[radius=1.5pt] node { };
    \draw[fill] (0,.5) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,0)  to [out=0,in=180] (.95,.5);
    \draw[-] (0,.5) to [out=0,in=180] (.95,0);
  \end{tikzpicture}
\end{minipage}

\noindent
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{dup}
\end{minipage}\hfill
\begin{minipage}{.25\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,.25) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,.25) to [out=-45,in=180] (.95,0);
    \draw[-] (0,.25) to [out=45,in=180] (.95,.5);
  \end{tikzpicture}
\end{minipage}

We can then define our first real example: \AF{`diag},
a static program taking a circuit with two inputs and
one output and returning a circuit with one input and
one output.
It does so by first duplicating the one input using \AF{`dup}
and then feeding it to both of the argument's ports.

\ExecuteMetaData[MetaCircuit.tex]{diag}

\begin{minipage}{.1\textwidth}
  $c \mapsto$
\end{minipage}
\begin{minipage}{.75\textwidth}
  \begin{tikzpicture}

    \coordinate (x) at (0,.25);
    \draw[fill] (x) circle[radius=1.5pt] node {};
    \draw (x)+(-.5,0) node {$x$} edge (x);

    \node[rectangle, draw, minimum height=.75cm, minimum width=.5cm] at (1, .25) (c) {$c$};

    \draw[-] (x) to [out=-45,in=180] ([yshift=.1cm] c.south west);
    \draw[-] (x) to [out=45,in=180] ([yshift=-.1cm] c.north west);

    \coordinate (r) at ([xshift=1cm] c);
    \draw[fill] (r) circle[radius=1.5pt] node {};
    \draw[-] (c.east) to (r);
    \draw (r)+(.5,0) node {$r$} edge (r);
  \end{tikzpicture}
\end{minipage}

We can then obtain the \AF{`not} gate by taking the diagonal
of the \AIC{`nand} built-in gate.

\ExecuteMetaData[MetaCircuit.tex]{not}

Staging this definition does evaluate away all of the function
calls to yield a simple circuit obtained by sequentially
composing \AF{`dup} and \AIC{`nand} as shown below.

\ExecuteMetaData[MetaCircuit.tex]{testNot}

Going back to a slightly more complex setting, if we add booleans in the
static layer, we can once again define more interesting terms like the
following \AF{`tab} which, given a function that takes a boolean
and computes a one-input one-output circuit, returns a circuit with two
inputs and one output that has the same behaviour.

\ExecuteMetaData[MetaCircuit.tex]{tab}

\begin{minipage}{.1\textwidth}
  $f \mapsto$
\end{minipage}\hfill
\begin{minipage}{.85\textwidth}
  \begin{tikzpicture}{circuit logic US}
    \coordinate (b) at (0,2);
    \draw[fill] (b) circle[radius=1.5pt] node {};
    \draw (b)+(-.5,0) node {$b$} edge (b);

    \coordinate (x) at (0,0);
    \draw[fill] (x) circle[radius=1.5pt] node {};
    \draw (x)+(-.5,0) node {$x$} edge (x);

    \node[rectangle, draw] at (2, 1.5) (f1) {$f\,1$};
    \draw[-] (x) to [out=45, in=180] (f1);

    \node[rectangle, draw] at (2, 0) (f0) {$f\,0$};
    \draw[-] (x) to [out=0, in=180] (f0);

    \draw (4, 0.15) node[and port, scale=.5] (and0) {};
    \draw[-] (f0) [out=0, in=180] to (and0.in 2);

    \draw (4, 1.85) node[and port, scale=.5] (and1) {};
    \draw[-] (b) [out=0, in=180] to (and1.in 1);
    \draw[-] (f1) [out=0, in=180] to (and1.in 2);

    \draw (2, .75) node[not port, scale=.35] (not0) {};
    \draw[-] (b) [out=-45, in=180] to (not0.in 1);
    \draw[-] (not0.out) [out=0, in=180] to (and0.in 1);

    \draw (6, 1) node[or port, scale=.5] (or01) {};
    \draw[-] (and1.out) [out=0, in=180] to (or01.in 1);
    \draw[-] (and0.out) [out=0, in=180] to (or01.in 2);

    \coordinate (tag) at (7,1);
    \draw[fill] (tag) circle[radius=1.5pt] node {};
    \draw (tag)+(.5,0) node {$r$} edge (tag);
    \draw[-] (or01.out) to (tag);
  \end{tikzpicture}
\end{minipage}

It is natural to want to generalise this term to one tabulating
a function computing circuits of with $i$ inputs and $o$ outputs
to obtain a circuit with $(1+i)$ inputs and $o$ outputs.
%
This would be possible in a setting where the static layer is
dependently typed like in Kov{\'{a}}cs' original paper.

\section{Related work}

\todo{Brigitte Pientka}
\todo{Mathys Rennela}
\todo{Bob's SMT paper}

\section{Future Work}

In this paper we focused on the model constructions and the
acquisition of a staging-by-evaluation function as a corollary.
Following Catarina Coquand's work on formalising normalisation
by evaluation~\cite{DBLP:journals/lisp/Coquand02} we could
additionally introduce the appropriate logical relations to
prove that this process is sound and complete with respect
to a small step semantics for the static layer.


Even though we have seen that having two wildly different
language layers can be extremely useful, a two-level
construction with exactly the same features is still very
useful: it lets programmers use their language of choice
as its own metaprogramming facilities.
%
Correspondingly, giving a generic treatment of the construction
taking a language and returning its standard two-level version
is an important endeavour.
%
A promising approach involves defining such a transformation
by induction over a universe of language
descriptions~\cite{DBLP:journals/jfp/AllaisACMM21}.

\section*{Acknowledgements}

\iftoggle{BLIND}{
  Thanks to XXX for comments.
}{
  We would like to thank Bob Atkey for his suggestion to index
  stages by a phase, thus allowing us to ensure that a staged
  term does not have any static subterm.
}

\newpage
\printbibliography
\end{document}
