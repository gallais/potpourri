\documentclass{article}

%%% Remark environment
\usepackage{amsthm}
\newtheorem*{remark}{Remark}

%%%% Agda code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{agda}
\input{unicode}
\usepackage{catchfilebetweentags}
\input{robust-catch}
% do not indent code blocks
\setlength\mathindent{0em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}
\setuptodonotes{inline}

\input{commands}

%%% Toggle
\newtoggle{BLIND}
\toggletrue{BLIND}


%%% References
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[style=alphabetic]{biblatex}
\bibliography{staging.bib}

%%% Inference rules
\usepackage{mathpartir}

\title{Scoped and Typed Staging by Evaluation}
\iftoggle{BLIND}{
  \author{ANONYMOUS}
}{
  \author{Guillaume Allais}
}

\begin{document}

\maketitle

\section{Introduction}

This paper gives an intrinsically scoped-and-typed
treatment of a simply typed version of the staged compilation
with two-level type theory introduced by
Kov{\'{a}}cs~\cite{DBLP:journals/pacmpl/Kovacs22}.
%
We use Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do)
and mobilise standard formalisation
techniques~\cite{DBLP:journals/lisp/Coquand02, DBLP:journals/jar/BentonHKM12}
and structures extensively studied by Allais, Chapman,
McBride, and McKinna (from now on refered to as ACMM)~\cite{DBLP:conf/cpp/Allais0MM17}.

Starting from a language with a static and a dynamic layer,
we perform a type-directed model construction
and define an evaluation function turning terms
into their semantical counterpart.
%
As a corollary, we obtain a staging function that
fully evaluates all of the static subterms and returns
purely dynamic ones.
%
As already observed by Kov{\'{a}}cs, this model construction
is analogous to the one used for normalisation by evaluation,
hence the title of this paper.

\todo{start with examples}

\section{A Primer on Intrinsically Typed λ-Calculi}\label{sec:intrinsictyping}

Let us start with a quick primer on intrinsically typed λ-calculi
defined in a dependently typed host language. The interested reader
can refer to ACMM~\cite{DBLP:conf/cpp/Allais0MM17} for a more in-depth
presentation of this approach.

\subsection{Object Types and Contexts}

We first give a sum type of object types. We call it \AF{Type} and
its own type is \AF{Set}, the type of all small types in Agda.
It has two constructors presented in generalised algebraic datatype
(GADT) fashion.
We use \AIC{`α} as our base type,
and (\AB{A} \AIC{`⇒} \AB{B}) is the type of functions from
\AB{A} to \AB{B}.

\ExecuteMetaData[STLC.tex]{type}

\begin{remark}[Syntax Highlighting]
  All the code in this paper is semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}, and comments are \AC{brown}.
\end{remark}

We extensively use Agda's \AK{variable} mechanism: all of
the seemingly unbound names will in fact have been automatically
quantified over in a prenex position provided that they
have been declared beforehand.
%
The following block for instance announces that from now
on unbound \AB{A}s and \AB{B}s stand for implicitly bound
\AD{Type} variables.

\ExecuteMetaData[STLC.tex]{typevariables}

Next, we form contexts as left-nested lists of types using
constructor names similar to the ones typically used in
inference rules.
Contexts may be the empty context \AIC{ε}
or a compound context (\AB{Γ} \AIC{,} \AB{A}) obtained
by extending an existing context \AB{Γ} on the right
with a newly bound (nameless) variable of type \AB{A}.

\ExecuteMetaData[STLC.tex]{context}

\subsection{Manipulating Indexed Types}

In this paper we are going to conform to the convention
of only mentioning context \emph{extensions} when
presenting judgements.
%
That is to say we will write the application and
λ-abstraction rules as they are in the right column
rather than the left one where the ambient context Γ
is mentioned explicitly.

\noindent
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{Γ ⊢ f : A → B \and Γ ⊢ t : A}{Γ ⊢ f \, t : B} \and
    \inferrule{Γ, x : A ⊢ b : B}{Γ ⊢ λx.b : A → B}
  \end{mathpar}
\end{minipage}\hfill
\begin{minipage}{.4\textwidth}
  \begin{mathpar}
    \inferrule{f : A → B \and t : A}{f \, t : B} \and
    \inferrule{x : A ⊢ b : B}{λx.b : A → B}
  \end{mathpar}
\end{minipage}

To do so, we need to introduce a small set of combinators
to manipulate indexed definitions. These are standard and
already present in Agda's standard library.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[STLC.tex]{forall}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{update}
\end{minipage}

First, \AF{∀[\_]} universally quantifies over its argument's index;
it is meant to be used to surround a complex expression built
up using the other combinators.
%
Second, the suggestively named \AF{\_⊢\_} allows us to modify
the index; it will be useful to extend a context with freshly
bound variables.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[STLC.tex]{arrow}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{product}
\end{minipage}

Third, we can form index-respecting function spaces using \AF{\_⇒\_}.
%
Finally, the pointwise lifting of pairing is called \AF{\_∩\_};
it will only come into play in \Cref{sec:stagingmodelprod}.

We include below an artificial example of a type written using
the combinators together with its full expansion using explicit
context-passing.

\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{swaptype}
  \ExecuteMetaData[STLC.tex]{swaptypenormalised}
\end{AgdaSuppressSpace}

\subsection{Intrinsically Typed Variables}

Our first inductive family formalises what it means for a variable of type
\AB{A} to be present in context \AB{Γ}. We present it side by side
with the corresponding inference rules for the typing judgement
for variables denoted ($\cdot :_v \cdot$).
%
The first constructor (\AIC{here}) states that in a non-empty context
where the most local variable has type \AB{A} we can indeed obtain a
variable of type \AB{A}.
%
The second one (\AIC{there}) states that if a variable of type \AB{A}
is present in a context then it also is present in the same context
extended with a freshly bound variable of type \AB{B}.

\noindent
\begin{minipage}{.5\textwidth}
\ExecuteMetaData[STLC.tex]{var}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{mathpar}
  \inferrule{ }{x : A ⊢ x :_v A} \and
  \inferrule{x :_v A}{y : B ⊢ x :_v A}
\end{mathpar}
\end{minipage}

This is a standard definition
corresponding to a scoped-and-typed variant of de Bruijn
indices~\cite{de1972lambda}.

\subsection{Intrinsically Typed Terms}

We are now ready to give the type of intrinsically typed terms.
It is an inductive family~\cite{DBLP:journals/fac/Dybjer94}
indexed over a type and a context.

\ExecuteMetaData[STLC.tex]{termdecl}

We will introduce constructors in turn, each accompanied by its
counterpart as an inference rule.
%
We start with the variable rule: a variable of type \AB{A} in
context forms a valid term of type \AB{A}.
%
As you can see below, we use a line lexed as a comment (\AC{---})
to suggestively typeset the constructor's type like the
corresponding rule.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termvar}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x :_v A}{x : A}
\end{mathpar}
\end{minipage}

Next with have the constructor for applications. It states that
by combining a term whose type is a function type from \AB{A} to \AB{B}
and a term of type \AB{A}, we obtain a term of type \AB{B}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termapp}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{f : A → B \and t : A}{f \, t : B}
\end{mathpar}
\end{minipage}

Last but not least, the rule for λ-abstraction is the only rule
with a premise mentioning a context extension. It states that
we can build a term for a function from \AB{A} to \AB{B} by
building the function's body of type \AB{B} in a context extended
by a freshly bound variable of type \AB{A}.

\noindent
\begin{minipage}[t]{.5\textwidth}
  \ExecuteMetaData[STLC.tex]{termlam}
\end{minipage}\hfill
\begin{minipage}[t]{.35\textwidth}
\begin{mathpar}
  \inferrule{x : A ⊢ b : B}{λx.b : A → B}
\end{mathpar}
\end{minipage}


Putting it all together, we obtain the following inductive family.

\begin{AgdaAlign}
\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{term}
\end{AgdaSuppressSpace}
\end{AgdaAlign}

\subsection{Renaming}

\ExecuteMetaData[STLC.tex]{ope}
\ExecuteMetaData[STLC.tex]{weakVar}
\ExecuteMetaData[STLC.tex]{weakTerm}


\subsection{Normalisation by Evaluation}

This whole process is based on Kripke semantics for intuitionistic
logic~\cite{DBLP:journals/apal/MitchellM91}.
As a consequence one of the central concepts is closure under future
worlds, here context extensions.
This idea is captured by the definition of the \AR{□} record: we
can inhabit (\AR{□} \AB{A} \AB{Γ}) whenever for any extension
\AB{Δ} of \AB{Γ} we are able to construct an (\AB{A} \AB{Δ}).

\ExecuteMetaData[STLC.tex]{box}

For more information on \AR{□} and its properties, the interested
reader can consult Allais, Atkey, Chapman, McBride, and
McKinna~\cite[Section~3.1]{DBLP:journals/jfp/AllaisACMM21}.
%

\ExecuteMetaData[STLC.tex]{kripke}

The model construction follows standard normalisation by
evaluation~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}.
The family of values is defined by induction on the value's
type.

\ExecuteMetaData[STLC.tex]{value}
\ExecuteMetaData[STLC.tex]{eval}

\section{Minimal Intrinsically Typed Two Level Type Theory}

We start with the smallest two level calculus we can possibly define
by extending the simply typed λ-calculus as defined in the previous
section with quotes and splices.

This will enable us to write and stage simple programs such as the following.

\ExecuteMetaData[BasicTwoTT.tex]{testid01}

The three-place relation (\AB{A} \AF{∋} \AB{s} \AF{↝} \AB{t}) states
that staging a term \AB{s} at type \AB{A} yields the term \AB{t}.
%
Here, \AF{`idᵈ} is a dynamic identity function
while \AF{`idˢ} is a static one,
\AIC{`⟨\_⟩} quotes a static term inside a dynamic one,
and \AIC{`∼\_} splices a dynamic term in a static one.
%
Correspondingly, staging will partially evaluate the call to
\AF{`idˢ} as well as all the quotes and splices while leaving
the rest of the term intact.
%
Hence the result: the call to the static identity function has
fully reduced but the call to the dynamic one has been preserved.


\subsection{Phases, Stages, and Types}

We start by defining a sum type of phases denoting whether
we are currently writing \AIC{source} code or inspecting
\AIC{staged} code that has already been partially evaluated.

\ExecuteMetaData[BasicTwoTT.tex]{phase}

Additionally, our notion of types is going to be explicitly
indexed by the stage they live in. These stages are indexed
over the phase they are allowed to appear in.
%
The \AIC{static} stage is only available in the \AIC{source}
phase: once code has been staged, all of its static parts will
be gone.
%
The \AIC{dynamic} stage however will be available in both
phases, hence the unconstrained index \AB{ph}.

\ExecuteMetaData[BasicTwoTT.tex]{stage}

We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[BasicTwoTT.tex]{types}

We have both static and dynamic terms of base type,
hence the unconstrained indices \AB{ph} and \AB{st}
for the constructor \AIC{`α}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime. This is only available in the
\AIC{source} phase.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.

Purely dynamic types in the source phase have a direct
counterpart in the staged one. We demonstrate this by
implementing the following \AF{asStaged} function.

\ExecuteMetaData[BasicTwoTT.tex]{asStaged}

It is essentially the identity function except for the
fact that its domain and codomain have different indices.

\subsection{Intrinsically Scoped and Typed Syntax}

We skip over the definition of contexts and variables: they
are essentially the same as the ones we gave in \Cref{sec:intrinsictyping}.

Our type of term is indexed by a phase, a stage, a type EZ

\ExecuteMetaData[BasicTwoTT.tex]{termdecl}

The first constructors are familiar: they are exactly the ones
seen in the previous section. These constructs are available
at both levels and both before and after staging hence the fact
that the state and phase indices are polymorphic here.

\ExecuteMetaData[BasicTwoTT.tex]{termstlc}

Next we have the constructs specific to the two level calculus:
quotes (\AIC{`⟨\_⟩}) let users insert dynamic terms into static
expressions while splices (\AIC{`∼\_}) allow static terms to
be inserted in dynamic ones.
%
Staging will, by definition, eliminate these and so their phase
indexed is constrained to be \AIC{source}.

\ExecuteMetaData[BasicTwoTT.tex]{termtwolevel}


Putting it all together, we obtain the following inductive
family representing a minimal intrinsically typed two-level
calculus.

\begin{AgdaAlign}
  \begin{AgdaSuppressSpace}
    \ExecuteMetaData[BasicTwoTT.tex]{term}
  \end{AgdaSuppressSpace}
\end{AgdaAlign}

We can readily write examples such as the following definitions
of a purely dynamic and a purely static identity function. The
dynamic function will survive staging even if it is applied to a
dynamic argument while the static one can only exist in the
source phase and will be fully evaluated during staging.

\noindent
\begin{minipage}{.4\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{iddyn}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{idsta}
\end{minipage}

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an \AF{eval}uation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.

\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}

As a corollary we will obtain a staging function
that takes a closed dynamic term and gets rid of all of
the quotes and splices by fully
evaluating all of its static parts.

\ExecuteMetaData[BasicTwoTT.tex]{stagedecl}

We start with the model construction describing precisely
the type of values.

\subsection{Model Construction}\label{sec:stagingmodel}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as staged terms
i.e. terms guaranteed not to contain any static subterm.

\ExecuteMetaData[BasicTwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation construction
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{modelstadecl}
\ExecuteMetaData[BasicTwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

There are no static values of type \AIC{`α} as this base type does
not have any associated constructors and so we return the empty type \AD{⊥};
values of type (\AIC{`⇑} \AB{A}) are dynamic values of type \AB{A}
i.e. staged terms of type \AB{A};
functions from \AB{A} to \AB{B} are interpreted using Kripke function
spaces from static values of type \AB{A} to static values of type \AB{B}.

\ExecuteMetaData[BasicTwoTT.tex]{thin}

\ExecuteMetaData[BasicTwoTT.tex]{kripke}

\ExecuteMetaData[BasicTwoTT.tex]{thinrefl}

\ExecuteMetaData[BasicTwoTT.tex]{kripkeapp}
\ExecuteMetaData[BasicTwoTT.tex]{kripkelam}


\subsection{Evaluation}

We can explain what the meaning of each term constructor is.
In every instance we will proceed by case analysis on the
stage the meaning is being used at.


Application is interpreted as the semantic application defined
for Kripke function spaces in the static case, and the syntactic
\AIC{`app} constructor in the dynamic one.

\ExecuteMetaData[BasicTwoTT.tex]{app}


\ExecuteMetaData[BasicTwoTT.tex]{lam}


\ExecuteMetaData[BasicTwoTT.tex]{extend}

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}
\ExecuteMetaData[BasicTwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{bodydecl}
\ExecuteMetaData[BasicTwoTT.tex]{body}
\end{AgdaSuppressSpace}

We obtain the \AF{stage} function by calling \AF{eval} with an
empty environment.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{stagefun}
\end{AgdaSuppressSpace}


\section{A More Practical Two Level Calculus}

We are now going to extend the minimal calculus we used so far to
show a more realistic example of a two level calculus.

First we are going to add natural numbers and their eliminator.
These will be available at both stages and we will see how we
can transfer a static natural number to the dynamic phase by
defining a static \AF{`reify} term.

Second, based on Kov{\'{a}}cs' observation that the static and
dynamic language do not need to have exactly the same features,
we are going to add a type of static pairs.
%
These pairs and their projections can be used in arbitrary static
code but will be guaranteed to be evaluated away during staging.
%
We will demonstrate this by giving a static term \AF{`fib}
implementing a standard linear (ignoring the cost of addition)
algorithm for the Fibonacci function.
%
This will allow us to obtain e.g.

\ExecuteMetaData[TwoTT.tex]{testfib}

\noindent where \AF{fromℕ} is a helper function turning Agda
literals into \AF{Term}s built using \AIC{`zero} and \AIC{`succ}.

\subsection{Adding natural numbers}

\subsubsection{Types and Terms}

\ExecuteMetaData[TwoTT.tex]{typesnat}

\ExecuteMetaData[TwoTT.tex]{termnat}

\ExecuteMetaData[TwoTT.tex]{reify}

\ExecuteMetaData[TwoTT.tex]{add}

\subsubsection{Staging by Evaluation}

Static values of type \AIC{`ℕ} are constant natural numbers.

\ExecuteMetaData[TwoTT.tex]{modelnat}

The term constructor \AIC{`zero} is either interpreted by
the natural number \AN{0} or by the term constructor itself
depending on whether it is used in a static or dynamic manner.

\ExecuteMetaData[TwoTT.tex]{zero}

Similarly \AIC{`succ} is interpreted either as (\AN{1} \AF{+}\AS{\_})
if it used in a static manner or by the term constructor itself
for dynamic uses.

\ExecuteMetaData[TwoTT.tex]{succ}

\ExecuteMetaData[TwoTT.tex]{iter}

\subsection{Adding static pairs}\label{sec:stagingmodelprod}

We now have an example of the fact, highlighted in Kov{\'{a}}cs'
original paper, that static datatypes do not need to have a
counterpart at runtime: pairs are only available in the static
layer and all traces of pairs and their projections will have
completely disappeared after staging.

\subsubsection{Types and Terms}

\ExecuteMetaData[TwoTT.tex]{typesprod}

\ExecuteMetaData[TwoTT.tex]{termprod}

\ExecuteMetaData[TwoTT.tex]{fib}

\subsubsection{Staging by Evaluation}

Static pairs are pairs of static values.

\ExecuteMetaData[TwoTT.tex]{modelprod}


\section{Application: Circuit Generation}

\cite{DBLP:conf/rc/GreenLRSV13,DBLP:conf/types/FlorSS15}

\section{Future Work}

Soundness and completeness
\cite{DBLP:journals/lisp/Coquand02}

Generic treatment of this construction
\cite{DBLP:journals/jfp/AllaisACMM21}

\section*{Acknowledgements}

\iftoggle{BLIND}{
  Thanks to XXX for comments.
}{
  We would like to thank Bob Atkey for his suggestion to index
  stages by a phase, thus allowing us to ensure that a staged
  term does not have any static subterm.
}

\newpage
\printbibliography
\end{document}
