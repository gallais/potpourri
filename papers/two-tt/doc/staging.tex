\begin{abstract}
  Using a dependently typed host language, we give a well
  scoped-and-typed by construction presentation of a minimal
  two level simply typed calculus with a static and a dynamic
  stage.
  %
  The staging function partially evaluating the part of a term
  that are static is obtained by a model construction inspired
  by normalisation by evaluation.

  We then go on to demonstrate how this minimal language can be
  extended to provide additional metaprogramming capabilities,
  and to define a higher order functional language evaluating
  to digital circuit descriptions.
\end{abstract}

\maketitle

\section{Introduction}

Staged compilation, by running arbitrary programs at compile
time in order to generate code, is a way to offer users
metaprogramming facilities.
%
Kov{\'{a}}cs demonstrated that the notion of two level
type theories, originally introduced in homotopy theory,
can be repurposed to describe layered languages equipped
with a staging operation partially evaluating the terms
in the upper layer~\cite{DBLP:journals/pacmpl/Kovacs22}.

In order to enable the mechanised study of such systems,
we give an intrinsically scoped-and-typed treatment of
various two level simply typed calculi and their
corresponding staging operations evaluating away all of
the static subterms.
%
We obtain these staging operations by performing type-directed
model constructions reminiscent of the ones used for normalisation
by evaluation, hence the title of this paper.

This culminates in a system that takes seriously Kov{\'{a}}cs'
remark that the static and dynamic layers do not need to have
exactly the same features. Its static layer is a higher order
functional language while the dynamic one corresponds to
digital circuit descriptions.
%
This casts existing work on high level languages for quantum
circuit descriptions into a new light as two level theories.

This work has been fully formalised using Agda~\cite{DBLP:conf/afp/Norell08}
as our host language (but any implementation
of Martin-Löf type theory~\cite{DBLP:books/daglib/0000395}
with inductive families~\cite{DBLP:journals/fac/Dybjer94}
would do).

\section{A Primer on Intrinsically Typed λ-Calculi}\label{sec:intrinsictyping}

Let us start with a quick primer on intrinsically scoped-and-typed λ-calculi
defined in a dependently typed host language. The interested reader
can refer to ACMM~\cite{DBLP:conf/cpp/Allais0MM17} for a more in-depth
presentation of this approach.

\subsection{Object Types and Contexts}

We first give an inductive definition of object types.
We call it \AF{Type} and its own type is \AF{Set},
the type of all small types in Agda.
It has two constructors presented in generalised algebraic
datatype fashion.
We use \AIC{`α} as our base type,
and (\AB{A} \AIC{`⇒} \AB{B}) is the type of functions from
\AB{A} to \AB{B}.

\ExecuteMetaData[STLC.tex]{type}

\begin{remark}[Syntax Highlighting]
  All of the code snippets in this paper are semantically highlighed:
  keywords are \AK{orange}, definitions and types are \AF{blue},
  data constructors are \AIC{green}, bound variables are
  \AB{slanted}, and comments are \AC{brown}.
\end{remark}

\begin{remark}[Implicit Prenex Polymorphism]
  We extensively use Agda's \AK{variable} mechanism: all of
  the seemingly unbound names will in fact have been automatically
  quantified over in a prenex position provided that they
  have been declared beforehand.
\end{remark}

The following block for instance announces that from now
on unbound \AB{A}s, \AB{B}s, and \AB{C}s stand for implicitly bound
\AD{Type} variables.

\ExecuteMetaData[STLC.tex]{typevariables}

Next, we form contexts as left-nested lists of types using
constructor names similar to the ones typically used in
type judgments.
Contexts may be the empty context \AIC{ε}
or a compound context (\AB{Γ} \AIC{,} \AB{A}) obtained
by extending an existing context \AB{Γ} on the right
with a newly bound (nameless) variable of type \AB{A}.

\ExecuteMetaData[STLC.tex]{context}

\subsection{Manipulating Indexed Types}

In this paper we are going to conform to the convention
of only mentioning context \emph{extensions} when
presenting judgements.
%
That is to say we will write the application and
λ-abstraction rules as they are in the right column
rather than the left one where the ambient context Γ
is explicitly threaded.

\noindent
\begin{minipage}{.2\textwidth}
  \begin{mathpar}
    \inferrule{Γ ⊢ f : A → B \and Γ ⊢ t : A}{Γ ⊢ f \, t : B} \and
    \inferrule{Γ, x : A ⊢ b : B}{Γ ⊢ λx.b : A → B}
  \end{mathpar}
\end{minipage}\hfill
\begin{minipage}{.2\textwidth}
  \begin{mathpar}
    \inferrule{f : A → B \and t : A}{f \, t : B} \and
    \inferrule{x : A ⊢ b : B}{λx.b : A → B}
  \end{mathpar}
\end{minipage}

To do so, we need to introduce a small set of combinators
to manipulate indexed definitions. These are commonplace
and already present in Agda's standard library.
%
First, \AF{∀[\_]} universally quantifies over its argument's index;
it is meant to be used to surround a complex expression built
up using the other combinators.

\ExecuteMetaData[STLC.tex]{forall}

Second, the suggestively named \AF{\_⊢\_} allows us to modify
the index; it will be useful to extend a context with freshly
bound variables.

\ExecuteMetaData[STLC.tex]{update}

Third, we can form index-respecting function spaces.

\ExecuteMetaData[STLC.tex]{arrow}

Finally, the pointwise lifting of pairing is called \AF{\_∩\_};
it will only come into play in \Cref{sec:stagingmodelprod}.

\ExecuteMetaData[STLC.tex]{product}

We include below an artificial example of a type written using
the combinators together with its full expansion using explicit
context-passing.

\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{swaptype}
  \ExecuteMetaData[STLC.tex]{swaptypenormalised}
\end{AgdaSuppressSpace}

\subsection{Intrinsically Typed Variables}

Our first inductive family~\cite{DBLP:journals/fac/Dybjer94} \AD{Var} formalises
what it means for a variable of type \AB{A} to be present in context \AB{Γ}.
It is indexed over said type and context.
We present it side by side
with the corresponding inference rules for the typing judgement
for variables denoted ($\cdot :_v \cdot$).
%
The first constructor (\AIC{here}) states that in a non-empty context
where the most local variable has type \AB{A} we can indeed obtain a
variable of type \AB{A}.
%
The second one (\AIC{there}) states that if a variable of type \AB{A}
is present in a context then it also is present in the same context
extended with a freshly bound variable of type \AB{B}.

\ExecuteMetaData[STLC.tex]{var}

\begin{mathpar}
  \inferrule{ }{x : A ⊢ x :_v A} \and
  \inferrule{x :_v A}{y : B ⊢ x :_v A}
\end{mathpar}

This is a standard definition
corresponding to a scoped-and-typed variant of De Bruijn
indices~\cite{de1972lambda,DBLP:journals/scp/BellegardeH94,DBLP:conf/csl/AltenkirchR99,DBLP:journals/jfp/BirdP99}:
\AIC{here} corresponds to zero, and \AIC{there} to successor.

\subsection{Intrinsically Typed Terms}

We are now ready to give the type of intrinsically typed terms.
It is once again an inductive family indexed over a type and a
context; its declaration is as follows.

\ExecuteMetaData[STLC.tex]{termdecl}

We will introduce constructors in turn, each paralleled by its
counterpart as an inference rule.
%
We start with the variable rule: a variable of type \AB{A}
forms a valid term of type \AB{A}.
%
As you can see below, we use a line lexed as a comment (\AC{----})
to suggestively typeset the constructor's type like the
corresponding rule.

\noindent
\begin{minipage}[t]{.25\textwidth}
  \ExecuteMetaData[STLC.tex]{termvar}
\end{minipage}\hfill
\begin{minipage}[t]{.17\textwidth}
\begin{mathpar}
  \inferrule{x :_v A}{x : A}
\end{mathpar}
\end{minipage}

Next we have the constructor for applications. It states that
by combining a term whose type is a function type from \AB{A} to \AB{B}
and a term of type \AB{A}, we obtain a term of type \AB{B}.

\noindent
\begin{minipage}[t]{.25\textwidth}
  \ExecuteMetaData[STLC.tex]{termapp}
\end{minipage}\hfill
\begin{minipage}[t]{.17\textwidth}
\begin{mathpar}
  \inferrule{f : A → B \and t : A}{f \, t : B}
\end{mathpar}
\end{minipage}

Last but not least, the rule for λ-abstraction is the only rule
with a premise mentioning a context extension. It states that
we can build a term for a function from \AB{A} to \AB{B} by
building the function's body of type \AB{B} in a context extended
by a freshly bound variable of type \AB{A}.

\noindent
\begin{minipage}[t]{.25\textwidth}
  \ExecuteMetaData[STLC.tex]{termlam}
\end{minipage}\hfill
\begin{minipage}[t]{.17\textwidth}
\begin{mathpar}
  \inferrule{x : A ⊢ b : B}{λx.b : A → B}
\end{mathpar}
\end{minipage}

Putting it all together, we obtain the following inductive family.

\begin{AgdaAlign}
\begin{AgdaSuppressSpace}
  \ExecuteMetaData[STLC.tex]{term}
\end{AgdaSuppressSpace}
\end{AgdaAlign}

This gives us the intrinsically scoped-and-typed syntax for
the simply typed lambda calculus.
And we give our first example: the identity function ($λ.0$ in de Bruijn notation).

\ExecuteMetaData[STLC.tex]{id}

As any well behaved syntax should,
it is stable under weakening as we are going to see shortly.

\subsection{Weakening}

Following Altenkirch, Hofmann, and Streicher~\cite{DBLP:conf/ctcs/AltenkirchHS95}
we start by defining the category of weakenings with contexts
as objects and the following inductive family as morphims.

\ExecuteMetaData[STLC.tex]{ope}

This relation on contexts, also known as order-preserving embeddings in the
literature, is a first order description of order-preserving
injections:
\AIC{done} is the trivial injection of the empty context into
itself;
\AIC{keep} extends an existing injection into one that preserves
the most local variable;
and \AIC{drop} records that the most local variable of the target
context does not have a pre-image via the injection.

We can define identity and composition of these morphisms (we leave
the definitions out but they are available in the accompanying material).

\noindent
\begin{minipage}{.15\textwidth}
  \ExecuteMetaData[STLC.tex]{lerefl}
\end{minipage}\hfill
\begin{minipage}{.27\textwidth}
  \ExecuteMetaData[STLC.tex]{letrans}
\end{minipage}

These order-preserving embeddings all have an action on suitably
well behaved scoped families. We will call these actions weakening
principles, and introduce the following type synonym to describe them.

\ExecuteMetaData[STLC.tex]{weaken}

The action on variables is given
by the following \AF{wkVar} definition. It is defined by
induction over the renaming and case analysis on the de Bruijn
index if the most local variable happens to be in both contexts.

\ExecuteMetaData[STLC.tex]{weakVar}

The action on terms is purely structural, with the caveat that
the weakening needs to be amended when going under a binder: the
most recently bound variable is present in both the source and
target contexts and so we use \AIC{keep} to mark it as retained.

\ExecuteMetaData[STLC.tex]{weakTerm}

Using these results, we can define function composition
as a pseudo constructor: provided $g$ and $f$, we form
$λx.g\,(f\, x)$ i.e. we use $g$ and $f$ in a context extended
with $x$ hence the need for weakening.

\label{def:composition}
\ExecuteMetaData[STLC.tex]{composition}

\begin{remark}[Lexing of Identifiers]
  Ignoring details about reserved characters for now: any
  space-free string of unicode characters is considered a
  single identifier.
  Correspondingly, in the example above \AB{Γ≤Γ,A} is a single
  identifier named like this to document for the human reader
  what its type looks like.
\end{remark}

\subsection{Normalisation by Evaluation}

It is now time to define an evaluation function for this syntax.
By the end of this section, we will have a function \AF{eval}
turning terms into Kripke-style values,
provided that we have an environment assigning values
to each of the term's free variables. It will have the following type.

\ExecuteMetaData[STLC.tex]{evaldecl}

\subsubsection{Kripke Function Spaces}

This whole process is based on Kripke semantics for intuitionistic
logic~\cite{DBLP:journals/apal/MitchellM91}.
As a consequence one of the central concepts is closure under future
worlds, here context extensions.
This idea is captured by the definition of the \AR{□} record: we
can inhabit (\AR{□} \AB{A} \AB{Γ}) whenever for any extension
\AB{Δ} of \AB{Γ} we are able to construct an (\AB{A} \AB{Δ}).

\ExecuteMetaData[STLC.tex]{box}

For more information on \AR{□} and its properties, see
Allais, Atkey, Chapman, McBride, and
McKinna~\cite[Section~3.1]{DBLP:journals/jfp/AllaisACMM21}.
%
We will only use the fact that it is a comonad, that is to say that
we can define \AF{extract} and \AF{duplicate} thanks to
the fact that the embedding relation is a preorder.

\ExecuteMetaData[STLC.tex]{extract}
\ExecuteMetaData[STLC.tex]{duplicate}

\begin{remark}[Copattern matching]
The definition of \AF{duplicate} proceeds by
copattern-matching~\cite{DBLP:conf/popl/AbelPTS13}.
This allows us to define values of a record type
(here \AR{□}) by defining the result of taking
each of its projections (here the unique \ARF{run□} one).
In this instance it is particularly useful because we have
a type involving nested records and each projection takes
additional arguments: an (implicit) context and a weakening
into that context.
\end{remark}

Kripke function spaces then correspond to functions inside a box,
hence the following definition.

\ExecuteMetaData[STLC.tex]{kripke}

The comonadic structure of \AF{□} additionally ensures we can define
semantic application (\AF{\_\$\$\_}) and weakening of Kripke function
spaces.

%% \noindent
%% \begin{minipage}{0.45\textwidth}
  \ExecuteMetaData[STLC.tex]{semapp}
%% \end{minipage}\hfill
%% \begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[STLC.tex]{weakKripke}
%% \end{minipage}

Finally, we introduce a notation to hide away \AR{□}-related
notions when building \AF{Kripke} functions.
%
After the following declarations we can write
\AIC{λλ[} \AB{σ} \AIC{,} \AB{v} \AIC{]} \AB{b} to implement a function of type
(\AF{Kripke} \AB{A} \AB{B} \AB{Γ}).

\ExecuteMetaData[STLC.tex]{mkbox}

\begin{remark}[Syntax Declarations]
  A \AK{syntax} declaration introduces syntactic sugar that is
  allowed to perform variable binding, or take arguments in a
  seemingly out-of-order manner.
  %
  In the above declaration the left hand side describes the
  actual term and the right hand side its newly introduced
  sugared form.
\end{remark}

We now have all of the ingredients necessary to perform the model
construction allowing us to implement a normaliser.

\subsubsection{Model Construction}

This step follows standard techniques for normalisation
by evaluation~\cite{DBLP:conf/lics/BergerS91,DBLP:journals/mscs/CoquandD97,DBLP:journals/lisp/Coquand02}.
The family of values is defined by induction on the value's
type.
%
Values of a base type are neutral terms (this is not enforced here and
we are happy to simply reuse \AF{Term}) while values of a function type
are Kripke function spaces between values of the domain and values of
the codomain.

\ExecuteMetaData[STLC.tex]{value}

We prove that values can be weakened by using the fact they are
defined in terms of families already known to be amenable to weakenings.

\ExecuteMetaData[STLC.tex]{weakValue}

Environments are functions associating a \AF{Value}
to each \AF{Var}iable in scope.

\ExecuteMetaData[STLC.tex]{env}

In the upcoming definition of the evaluation function, environments
will in general simply be threaded through. They will only need to
be modified when going under a binder. This binder, interpreted as
a Kripke function space, will provide a context weakening and a value
living in that context.
%
The environment will have to be extended with the value while its
existing content will need to be transported, along the weakening,
into the bigger context.
%
The \AF{extend} definition combines these two operations into a single
one. It is defined in copattern style:
{\AS{.}\ARF{run□}} builds a box while {\AS{.}\ARF{get}} builds the
returned environment. The definition proceeds by case analysis on the
variable to be mapped to a value: if it is the newly bound one, we
immediately return the value we just obtained, and otherwise we look
up the associated value in the old environment and use \AB{σ} to
appropriately weaken it.

\ExecuteMetaData[STLC.tex]{extend}

The evaluation function maps terms to values provided that
an environment assigns a value to every free variable in scope.
It is defined by induction on the term and maps every construct
to its semantical counterpart: variables become environment lookups,
application become Kripke applications, and λ-abstractions become
Kripke functions.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[STLC.tex]{eval}
\end{AgdaSuppressSpace}

A typical normalisation by evaluation presentation would
conclude with the definition of a reification function
extracting a term from a value in a type-directed manner
before defining normalisation as the composition of evaluation
and reification.
%
This last step will however not be useful for our study of two
level calculi and so we leave it out. It can be found in details
in Catarina Coquand's work on normalisation by evaluation for
a simply typed λ-calculus with explicit
substitutions~\cite{DBLP:journals/lisp/Coquand02}.

Now that we have seen how to define a small well scoped-and-typed
language and construct an evaluation function by performing a model
construction, we can start looking at a extending it to two level
language.

\section{Minimal Intrinsically Typed Two Level Type Theory}

We start with the smallest two level calculus we can possibly define
by extending the simply typed λ-calculus as defined in the previous
section with quotes (\AIC{`⟨\_⟩}) and splices (\AIC{`∼\_}).

This will enable us to write and stage simple programs such as the following.

\ExecuteMetaData[BasicTwoTT.tex]{testid01}

The three-place relation (\AB{A} \AF{∋} \AB{s} \AF{↝} \AB{t}) states
that staging a term \AB{s} at type \AB{A} yields the term \AB{t}.
%
Here, \AF{`idᵈ} is a dynamic identity function
while \AF{`idˢ} is a static one,
\AIC{`⟨\_⟩} quotes a static term inside a dynamic one,
and \AIC{`∼\_} splices a dynamic term in a static one.
%
Correspondingly, staging will partially evaluate the call to
\AF{`idˢ} as well as all the quotes and splices while leaving
the rest of the term intact.
%
Hence the result: the call to the static identity function has
fully reduced but the call to the dynamic one has been preserved.


\subsection{Phases, Stages, and Types}

We start by defining a sum type of phases denoting whether
we are currently writing \AIC{src} code or inspecting
\AIC{stg} code that has already been partially evaluated.

\ExecuteMetaData[BasicTwoTT.tex]{phase}

Additionally, our notion of types is going to be explicitly
indexed by the stage they live in. These stages are themselves
indexed over the phase they are allowed to appear in.
%
The static (\AIC{sta}) stage is only available in the \AIC{src}
phase: once code has been staged, all of its static parts will
be gone.
%
The dynamic (\AIC{dyn}) stage however will be available in both
phases, hence the unconstrained index \AB{ph}.

\ExecuteMetaData[BasicTwoTT.tex]{stage}

We can now define our inductive family of simple types indexed
by their stage.

\ExecuteMetaData[BasicTwoTT.tex]{types}

We have both static and dynamic terms of base type,
hence the unconstrained indices \AB{ph} and \AB{st}
for the constructor \AIC{`α}.
%
The constructor \AIC{‘⇑\_} allows us to embed dynamic
types into static ones; (\AIC{‘⇑} \AB{A}) is effectively
the type of \emph{programs} that will compute a value of
type \AB{A} at runtime. This is only available in the
\AIC{src} phase.
%
Function types are available in both layers provided that
they are homogeneous: both the domain and codomain need
to live in the same layer.

Purely dynamic types in the source phase have a direct
counterpart in the staged one. We demonstrate this by
implementing the following \AF{asStaged} function.

\ExecuteMetaData[BasicTwoTT.tex]{asStaged}

It is essentially the identity function except for the
fact that its domain and codomain have different indices.

\subsection{Intrinsically Scoped and Typed Syntax}

We skip over the definition of contexts and variables: they
are essentially the same as the ones we gave in \Cref{sec:intrinsictyping}.

Our type of term is indexed by a phase, a stage, a type
at that stage, and a context.

\ExecuteMetaData[BasicTwoTT.tex]{termdecl}

The first constructors are familiar: they are exactly the ones
seen in the previous section. These constructs are available
at both levels and both before and after staging hence the fact
that the phase and stage indices are polymorphic here.

\ExecuteMetaData[BasicTwoTT.tex]{termstlc}

Next we have the constructs specific to the two level calculus:
quotes (\AIC{`⟨\_⟩}) let users insert dynamic terms into static
expressions while splices (\AIC{`∼\_}) allow static terms to
be inserted in dynamic ones.
%
Staging will, by definition, eliminate these and so their phase
index is constrained to be \AIC{src}.

\ExecuteMetaData[BasicTwoTT.tex]{termtwolevel}


Putting it all together, we obtain the following inductive
family representing a minimal intrinsically typed two-level
calculus.

\begin{AgdaAlign}
  \begin{AgdaSuppressSpace}
    \ExecuteMetaData[BasicTwoTT.tex]{term}
  \end{AgdaSuppressSpace}
\end{AgdaAlign}

We can readily write examples such as the following definitions
of a purely dynamic and a purely static identity function. The
dynamic function will survive staging even if it is applied to a
dynamic argument while the static one can only exist in the
source phase and will be fully evaluated during staging.

\noindent
\begin{minipage}{.21\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{iddyn}
\end{minipage}\hfill
\begin{minipage}{.23\textwidth}
  \ExecuteMetaData[BasicTwoTT.tex]{idsta}
\end{minipage}

Now that we have a syntax, we can start building the machinery
that will actually perform its partial evaluation.

\section{Staging by Evaluation}

The goal of this section is to define a type of \AF{Value}s
as well as an evaluation function which computes the
value associated to each term, provided that we have an
appropriate environment to interpret the term's free variables.
%
This will once again yield a function \AF{eval} of the following type.

\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}

As a corollary we will obtain a staging function
that takes a closed dynamic term and gets rid of all of
the quotes and splices by fully
evaluating all of its static parts.

\ExecuteMetaData[BasicTwoTT.tex]{stagedecl}

We start with the model construction describing precisely
the type of values.

\subsection{Model Construction}\label{sec:stagingmodel}

The type of values is defined by case analysis on the stage.
%
Static values are given a static meaning (defined below)
while dynamic values are given a meaning as staged terms
i.e. terms guaranteed not to contain any static subterm.

\ExecuteMetaData[BasicTwoTT.tex]{model}

The family of static values is defined by induction on
the value's type. It is fairly similar to the standard
normalisation by evaluation construction
except that static values at a base types cannot possibly
be neutral terms.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{modelstadecl}
\ExecuteMetaData[BasicTwoTT.tex]{modelsta}
\end{AgdaSuppressSpace}

There are no static values of type \AIC{`α} as this base type does
not have any associated constructors and so we return the empty type \AD{⊥};
values of type (\AIC{`⇑} \AB{A}) are dynamic values of type \AB{A}
i.e. staged terms of type \AB{A};
functions from \AB{A} to \AB{B} are interpreted using Kripke function
spaces from static values of type \AB{A} to static values of type \AB{B}.

\subsection{Evaluation}

We can now explain what the meaning of each term constructor is.
In every instance we will proceed by case analysis on the
stage the meaning is being used at, essentially using a
meaning inspired by normalisation by evaluation for the static
part and one inspired by substitution for the dynamic one.

Application is interpreted as the semantic application defined
for Kripke function spaces in the static case, and the syntactic
\AIC{`app} constructor in the dynamic one.

\ExecuteMetaData[BasicTwoTT.tex]{app}

Lambda-abstraction are mapped to Kripke λs for static values
and to syntactic ones for the dynamic ones.

\ExecuteMetaData[BasicTwoTT.tex]{lam}

Putting it all together, we obtain the following definition
of the evaluation function.
Note that by virtue of the model construction the interpretation
of both \AIC{`∼\_} and \AIC{`⟨\_⟩} is the identity function:
static values of type (\AIC{`⇑} A) and staged terms of type \AB{A}
are interchangeable.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{evaldecl}
\ExecuteMetaData[BasicTwoTT.tex]{eval}
\end{AgdaSuppressSpace}

The function \AF{eval} is mutually defined with an auxiliary
function describing its behaviour on the body of a λ-abstraction.
It is defined using semantics lambdas and \AF{extend}.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{bodydecl}
\ExecuteMetaData[BasicTwoTT.tex]{body}
\end{AgdaSuppressSpace}

We finally obtain the \AF{stage} function by calling \AF{eval} with an
empty environment.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[BasicTwoTT.tex]{stagefun}
\end{AgdaSuppressSpace}

\begin{remark}[(Co)Pattern-Matching Lambda]
The keyword (\AS{λ} \AK{where}) is analogous to Haskell's
\texttt{\textbackslash{}case}: it introduces a pattern-matching lambda.
In this instance, it is a copattern-matching one: we define
the environment of type (\AR{Env} \AIC{ε} \AIC{ε}) by
copattern-matching on {\AS{.}\ARF{get}} which allows us to bind
an argument of type (\AD{Var} \AB{A} \AIC{ε}) that can in turn
be immediately dismissed as uninhabited using the empty pattern \AS{()}.
\end{remark}

\section{A More Practical Two Level Calculus}

We are now going to extend the minimal calculus we used so far to
show a more realistic example of a two level calculus.

First we are going to add natural numbers and their eliminator.
These will be available at both stages and we will see how we
can transfer a static natural number to the dynamic phase by
defining a static \AF{`reify} term.

Second, based on Kov{\'{a}}cs' observation that the static and
dynamic language do not need to have exactly the same features,
we are going to add a type of static pairs.
%
These pairs and their projections can be used in arbitrary static
code but will be guaranteed to be evaluated away during staging.
%
We will demonstrate this by giving a static term \AF{`fib}
implementing a standard linear (ignoring the cost of addition)
algorithm for the Fibonacci function.
%
This will allow us to obtain e.g.

\ExecuteMetaData[TwoTT.tex]{testfib}

\noindent where \AF{fromℕ} is a helper function turning Agda
literals into \AF{Term}s built using \AIC{`zero} and \AIC{`succ},
and \AF{`add} is a dynamic addition function.
%
Note that the dynamic call to addition was not evaluated
away during staging.

\subsection{Adding natural numbers}

Our first extension adds the inductive type of Peano-style natural numbers,
its two constructors, and the appropriate eliminator for it.

\subsubsection{Types and Terms}

First we extend the definition of \AD{Type} with a new constructor
\AIC{`ℕ}. Natural numbers will be present at both stages and so we
allow the index to be polymorphic.

\ExecuteMetaData[TwoTT.tex]{typesnat}

We then add \AD{Term} constructors for the two Peano-style
constructors (\AIC{`zero} and \AIC{`succ}) as well as an
eliminator (\AIC{`iter}) which turns a natural number into
its Church encoding~\cite[Chapter 3]{church1941calculi}.

\ExecuteMetaData[TwoTT.tex]{termnat}

Our first program example is the function \AF{`reify} that
turns its static natural number argument into a dynamic
encoding. It does so by iterating over its input and replacing
static \AIC{`zero}s and \AIC{`succ}s by dynamic ones.

\ExecuteMetaData[TwoTT.tex]{reify}

We can also naturally define addition as iterated calls to
\AIC{`succ}. This definition is valid at both stages hence
the polymorphic phase and stage indices.

\label{def:add}
\ExecuteMetaData[TwoTT.tex]{add}

Let us now see how to evaluate the newly added constructs.

\subsubsection{Staging by Evaluation}

We extend the definition of \AF{Static} with a new clause decreeing
that values of type \AIC{`ℕ} are constant natural numbers.

\ExecuteMetaData[TwoTT.tex]{modelnat}

We can then describe the semantical counterparts of the newly
added constructors.
%
The term constructor \AIC{`zero} is either interpreted by
the natural number \AN{0} or by the term constructor itself
depending on whether it is used in a static or dynamic manner.

\ExecuteMetaData[TwoTT.tex]{zero}

Similarly \AIC{`succ} is interpreted either as (\AN{1} \AF{+}\AS{\_})
if it used in a static manner or by the term constructor itself
for dynamic uses.

\ExecuteMetaData[TwoTT.tex]{succ}

The meaning of \AIC{`iter} in the static layer is defined in
terms of the \AF{iterate} function defined by pattern-matching
in the host language and turning a natural number into its
Church encoding. Note that we need to use \AF{wkKripke} to
bring the \AB{succ} argument into the wider scope the \AB{zero}
one lives int.

\ExecuteMetaData[TwoTT.tex]{iter}


We can readily compute with these numbers. Reifying the static
result obtained by adding $7$ to $35$ will for instance return
$42$ (here \AF{fromℕ} once again stands for a helper function
turning Agda literals into \AD{Term} numbers).

\ExecuteMetaData[TwoTT.tex]{testadd}

Let us now look at an example of the fact, highlighted in
Kov{\'{a}}cs' original paper, that static datatypes do not
need to have a counterpart at runtime.

\subsection{Adding static pairs}\label{sec:stagingmodelprod}

We now want to add pairs that are only available in the static
layer and ensure that all traces of pairs and their projections
will have completely disappeared after staging.

\subsubsection{Types and Terms}

We first extend the inductive definition of object types
with a new construct for pair types. It is explicitly
marked as \AIC{sta} only.

\ExecuteMetaData[TwoTT.tex]{typesprod}

We then extend the inductive family of term constructs
with a constructor for pairs (\AIC{\_`,\_}) and two constructors
for the first (\AIC{`fst}) and second (\AIC{`snd}) projection
respectively.

\ExecuteMetaData[TwoTT.tex]{termprod}

This enables us to implement in the static layer the classic
linear definition of the Fibonacci function which internally
uses a pair of the current Fibonacci number and its successor.
%
It is obtained by taking the first projection of the result
of iterating the invariant-respecting \emph{step} function
over the valid \emph{base} case.

\ExecuteMetaData[TwoTT.tex]{fib}

This definition uses \AF{\_`∘\_} defined in~\Cref{def:composition},
and \AF{`add} defined in~\Cref{def:add}.

\subsubsection{Staging by Evaluation}

The amendment to the model construction and the definition of the
constructors' semantical counterparts is easy.
%
First, static pairs are pairs of static values.

\ExecuteMetaData[TwoTT.tex]{modelprod}

Second, pair constructors are mapped to pair constructors in
the host language, and the same for projections.

\ExecuteMetaData[TwoTT.tex]{evalprod}

These definition now allow us to evaluate static calls to the Fibonacci
function such as the one presented in this section's introduction.

\ExecuteMetaData[TwoTT.tex]{testfib}

While this addition of static pairs may seem interesting
but anecdotal, the same techniques can be used to work on
defining a much more applicable two level language.

\section{Application: Circuit Generation}\label{sec:circuits}

This section's content is inspired by Quipper, a functional
programming language to describe quantum computations
introduced by Green, Lumsdaine, Ross, Selinger, and
Valiron~\cite{DBLP:conf/rc/GreenLRSV13} and related
formal treatments such as Rennela and Staton's categorical
models~\cite{DBLP:journals/lmcs/RennelaS19}.
%
This strand of research gives us a good example of a setting in which
we have two very distinct layers: a static layer with a
full-fledged functional language, and a dynamic layer of
quantum circuits obtained by partially evaluating the source.

In our proof of concept, we study a minimal language of
classical circuits inspired by Π-ware a formal hardware
description and verification language proposed by
Flor, Swierstra, and Sijsling~\cite{DBLP:conf/types/FlorSS15}.
%
This allows us to focus on the two-level aspect instead of
having to deal with linearity and unitary operators which are
specific to the Quantum setting.

\subsection{Types and Terms}

Our definition of types should now be mostly unsurprising.
We have function spaces (this time confined to the static
layer), a lifting construct allowing the embedding of
dynamic types in the static layer at the source stage,
and finally a type of circuits
\AIC{⟨}~\AB{i}~\AIC{∣}~\AB{o}~\AIC{⟩} characterised by
their input (\AB{i}) and output (\AB{o}) arities,
each represented by a natural number in the host language.

\ExecuteMetaData[MetaCircuit.tex]{type}

Next, we extend the basic simply typed lambda calculus with
quotes and splices with term constructors for circuit descriptions.
They will all belong to the dynamic stage.
%
Our first constructor gives us the universal nand gate.
Its type records the fact it takes two inputs and returns
a single output.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitnand}

Next, we have a constructor for the parallel composition
of existing circuits. The input and output arities of the
resulting circuit are obtained by adding up the respective
input and output arities of each of the components.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitpar}

We can also compose circuits sequentially, provided
that the output arity of the first circuit matches
the input arity of the second.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitseq}

Finally, we follow the Π-ware~\cite{DBLP:conf/types/FlorSS15}
approach and offer a general rewiring component.
A `mix' of $i$ inputs returning $o$ outputs is defined by
a vector (i.e. a list of known length) of size $o$
containing finite numbers between $0$ and $i$
corresponding to the input the output is connected to.
%
This allows arbitrary duplications and deletions
of inputs.

\ExecuteMetaData[MetaCircuit.tex]{termcircuitmix}

Typical examples include
\AF{`id$_2$} (the \emph{id}entity circuit on two inputs),
\AF{`swap} (the circuit \emph{swap}ping its two inputs),
and \AF{`dup} (the circuit \emph{dup}licating its single input).
We present them below together with the corresponding wiring diagrams.

\noindent
\begin{minipage}{.25\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{id2}
\end{minipage}\hfill
\begin{minipage}{.125\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,0)  circle[radius=1.5pt] node { };
    \draw[fill] (0,.5) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,0)  to [out=0,in=180] (.95,0);
    \draw[-] (0,.5) to [out=0,in=180] (.95,.5);
  \end{tikzpicture}
\end{minipage}

\noindent
\begin{minipage}{.25\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{swap}
\end{minipage}\hfill
\begin{minipage}{.125\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,0)  circle[radius=1.5pt] node { };
    \draw[fill] (0,.5) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,0)  to [out=0,in=180] (.95,.5);
    \draw[-] (0,.5) to [out=0,in=180] (.95,0);
  \end{tikzpicture}
\end{minipage}

\noindent
\begin{minipage}{.25\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{dup}
\end{minipage}\hfill
\begin{minipage}{.125\textwidth}
  \begin{tikzpicture}
    \draw[fill] (0,.25) circle[radius=1.5pt] node { };

    \draw[fill] (1,0)  circle[radius=1.5pt] node { };
    \draw[fill] (1,.5) circle[radius=1.5pt] node { };

    \draw[-] (0,.25) to [out=-45,in=180] (.95,0);
    \draw[-] (0,.25) to [out=45,in=180] (.95,.5);
  \end{tikzpicture}
\end{minipage}

We can then define our first real example: \AF{`diag},
a static program taking a circuit with two inputs and
one output and returning a circuit with one input and
one output.
It does so by first duplicating the one input using \AF{`dup}
and then feeding it to both of the argument's ports.
%
We present it below together with the corresponding
circuit diagram.

\ExecuteMetaData[MetaCircuit.tex]{diag}

\medskip
\begin{minipage}{.05\textwidth}
  $c \mapsto$
\end{minipage}
\begin{minipage}{.375\textwidth}
  \begin{tikzpicture}

    \coordinate (x) at (0,.25);
    \draw[fill] (x) circle[radius=1.5pt] node {};
    \draw (x)+(-.5,0) node {$x$} edge (x);

    \node[rectangle, draw, minimum height=.75cm, minimum width=.5cm] at (1, .25) (c) {$c$};

    \draw[-] (x) to [out=-45,in=180] ([yshift=.1cm] c.south west);
    \draw[-] (x) to [out=45,in=180] ([yshift=-.1cm] c.north west);

    \coordinate (r) at ([xshift=1cm] c);
    \draw[fill] (r) circle[radius=1.5pt] node {};
    \draw[-] (c.east) to (r);
    \draw (r)+(.5,0) node {$r$} edge (r);
  \end{tikzpicture}
\end{minipage}
\medskip

We can then obtain the \AF{`not} gate by taking the diagonal
of the \AIC{`nand} built-in gate.

\ExecuteMetaData[MetaCircuit.tex]{not}

Staging this definition does evaluate away all of the function
calls to yield a simple circuit obtained by sequentially
composing \AF{`dup} and \AIC{`nand} as shown below.

\ExecuteMetaData[MetaCircuit.tex]{testNot}

Using standard constructions, we can define \AF{`and} and \AF{`or}
in terms of the universal \AIC{`nand} gate.

\noindent
\begin{minipage}{.22\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{and}
\end{minipage}\hfill
\begin{minipage}{.22\textwidth}
  \ExecuteMetaData[MetaCircuit.tex]{or}
\end{minipage}

Going back to a slightly more complex setting, adding booleans in the
static layer lets us once again define more interesting terms.
For instance, the following \AF{`tab} circuit \emph{tab}ulating its
input: given a function that takes a boolean and computes a one-input
one-output circuit, it returns a circuit with two inputs and one
output that has the same behaviour.

\ExecuteMetaData[MetaCircuit.tex]{tab}

Using dashed lines to separate the different constituting parts
of the circuit as defined above, we obtain the following circuit
diagram.

\medskip
\begin{minipage}{.05\textwidth}
  $f \mapsto$
\end{minipage}\hfill
\begin{minipage}{.425\textwidth}\scalebox{.85}{
  \begin{tikzpicture}{circuit logic US}
    \coordinate (b) at (0,2);
    \draw[fill] (b) circle[radius=1.5pt] node {};
    \draw (b)+(-.5,0) node {$b$} edge (b);

    \coordinate (x) at (0,0);
    \draw[fill] (x) circle[radius=1.5pt] node {};
    \draw (x)+(-.5,0) node {$x$} edge (x);

    \node[rectangle, draw] at (2, 1.5) (f1) {$f\,1$};
    \draw[-] (x) to [out=45, in=180] (f1);

    \node[rectangle, draw] at (2, 0) (f0) {$f\,0$};
    \draw[-] (x) to [out=0, in=180] (f0);

    \draw (4, 0.15) node[and port, scale=.5] (and0) {};
    \draw[-] (f0) [out=0, in=180] to (and0.in 2);

    \draw (4, 1.85) node[and port, scale=.5] (and1) {};
    \draw[-] (b) [out=0, in=180] to (and1.in 1);
    \draw[-] (f1) [out=0, in=180] to (and1.in 2);

    \draw (2, .65) node[not port, scale=.35] (not0) {};
    \draw[-] (b) [out=-45, in=180] to (not0.in 1);
    \draw[-] (not0.out) [out=0, in=180] to (and0.in 1);

    \draw (6, 1) node[or port, scale=.5] (or01) {};
    \draw[-] (and1.out) [out=0, in=180] to (or01.in 1);
    \draw[-] (and0.out) [out=0, in=180] to (or01.in 2);

    \coordinate (tag) at (7,1);
    \draw[fill] (tag) circle[radius=1.5pt] node {};
    \draw (tag)+(.5,0) node {$r$} edge (tag);
    \draw[-] (or01.out) to (tag);

    \draw[dashed] ([xshift=-.25cm, yshift=1cm] x) to ([xshift=.5cm, yshift=1cm] x);
    \draw[dashed] ([xshift=.5cm, yshift=.4cm] b) to ([xshift=.5cm, yshift=-.4cm] x);
    \draw[dashed] ([xshift=1.25cm, yshift=.4cm] b) to ([xshift=1.25cm, yshift=-.4cm] x);
    \draw[dashed] ([xshift=3cm, yshift=.4cm] b) to ([xshift=3cm, yshift=-.4cm] x);
    \draw[dashed] ([xshift=4.75cm, yshift=.4cm] b) to ([xshift=4.75cm, yshift=-.4cm] x);
    \draw[dashed] ([xshift=1.25cm, yshift=1cm] x) to ([xshift=4.75cm, yshift=1cm] x);

  \end{tikzpicture}}
\end{minipage}
\medskip

This term is not in and of itself particularly useful but its
generalisation to one that could take a function computing an
{\AIC{⟨}~\AB{i}~\AIC{∣}~\AB{o}~\AIC{⟩}} circuit and return an
equivalent {\AIC{⟨}~\AN{1}~\AF{+}~\AB{i}~\AIC{∣}~\AB{o}~\AIC{⟩}}
circuit would allow us to build arbitrarily complex circuits
by tabulating static n-ary boolean functions.

This would however require a setting where the static layer is
dependently typed like in Kov{\'{a}}cs' original work, something
out of scope for this paper.

\section{Related work}

Prior work on partial evaluation and metaprogramming
abounds so we will only focus on the very most relevant
works involving strong types.

\paragraph{Quantum Circuits Generation}
As already mentioned in \Cref{sec:circuits}, such two level
systems occur naturally when defining high level languages
for (quantum) circuit descriptions.
%
Rennela and Staton's EWire language is itself the categorical
treatment of a minor generalisation of Paykin, Rand,
and Zdancewic's QWire~\cite{DBLP:conf/popl/Paykin0Z17},
a clear invariant-enforcing improvement over the weakly
typed Haskell embedded domain specific language Quipper~\cite{DBLP:conf/rc/GreenLRSV13}.
%
EWire is an ad-hoc construction which, although not worded
explicitly in terms of a two level type theory, effectively
is one: quotes and splices are called boxing and unboxing,
and a QWire-inspired partial normalisation procedure
proven to be semantics-preserving is defined.

\paragraph{SMT Constraints Generation}
In their work on compiling higher order specifications to SMT
constraints~\cite{DBLP:conf/cpp/DaggittAKKA23},
Daggit, Atkey, Kokke, Komendantskaya, and Arnaboldi
designed a cunning 'translation by evaluation' to
partially evaluate specifications written in a full featured
high level functional language (without recursion)
into first order SMT constraints.
%
This is not explicitly designed as a two level system and
so the sucess of the partial evaluation comes from a careful
but ultimately ad-hoc design rather than a systematic approach.
%
Unlike ours, their system however comes with a proof of
correctness: the generated formula is proven to be logically
equivalent to the high level specification.
%
This is an obvious avenue for future work on our part.

\paragraph{Typed Metaprogramming}
Jang, Gélineau, Monnier, and Pientka's
Mœbius~\cite{DBLP:journals/pacmpl/JangGMP22} defines
a type theory with a built in notion of quasiquotations
that can be used to generate programs in a type-safe
manner.
%
The language lets metaprograms inspect the code fragments
they are passed as arguments thus allowing e.g. the
implementation of optimisation passes post-processing the
result of a prior metaprogram.
%
This is extremely powerful, at the cost of a more complex
underlying theory.
%
In Mœbius the meta and object language are essentially the
same but it does not seem to be a necessary restriction.

\section{Future Work}

\paragraph{Soundness and Completeness}
We focused here on the intrinsically typed language description,
the corresponding model construction, and the acquisition of a
staging-by-evaluation function as a corollary.
%
Following Catarina Coquand's work on formalising normalisation
by evaluation~\cite{DBLP:journals/lisp/Coquand02} we could
additionally introduce the appropriate logical relations to
prove that this process is sound and complete with respect
to a small step semantics for the static layer.

\paragraph{Dependently Typed Circuit Description Language}
Our undergraduates are already being taught digital logic
using a functional-style circuit description language.
Extending it with a dependently typed meta-programming
layer would allow them to structure their understanding
of the generic construction of arithmetic circuits for
arbitrarily large inputs.

\paragraph{Generic Two Level Construction}
Even though we have seen that having two wildly different
language layers can be extremely useful, a two-level
construction with exactly the same features is still very
useful: it lets programmers use their language of choice
as its own metaprogramming facilities.
%
Correspondingly, giving a generic treatment of the construction
taking a language and returning its standard two-level version
is an important endeavour.
%
A promising approach involves defining such a transformation
by induction over a universe of language
descriptions~\cite{DBLP:journals/jfp/AllaisACMM21}.
