\section{Descriptions}\label{sec:desc}

We first need to pin down the domain of our discourse.
%
To talk generically about an entire class of datatypes
without needing to modify the host language
we have decided to perform a universe
construction~\cite{benke-ugpp, DBLP:phd/ethos/Morris07, DBLP:conf/icfp/LohM11}.
%
That is to say that we are going to introduce an inductive type
defining a set of codes together
with an interpretation of these codes as bona fide
host-language types.
%
We will then be able to program generically over the universe of
datatypes by performing induction on the type of
codes~\cite{DBLP:conf/tphol/PfeiferR99}.

In our setting, constructors are essentially arbitrarily nested tuples of
values of type unit,
bytes,
and recursive substructures.
%
A datatype is given by listing a choice of constructors.

\subsection{Descriptions}

We start with these constructor descriptions;
they are represented internally by an inductive family \IdrisType{Desc}
declared below.

\ExecuteMetaData[Serialised/Desc.idr.tex]{desctype}

This family has three indices corresponding to three crucial
invariants being tracked.
%
First, whether the current description is being used in the
\IdrisBound{rightmost} branch of the overall constructor description.
%
Second, the \IdrisBound{static}ally known size of the described data
in the number of bytes it occupies.
%
Third, the number of \IdrisBound{offsets} that need to be stored to
compensate for subterms not having a statically known size.

Next we define the family proper by giving its four constructors.

\ExecuteMetaData[Serialised/Desc.idr.tex]{desc}

Each constructor can be used anywhere in a description so their return
\IdrisBound{rightmost} index can be an arbitrary boolean.

\IdrisData{None} is the description of values of type unit. The static
size of these values is zero as no data is stored in a value of type unit.
Similarly, they do not require an offset to be stored as we statically
know their size.

\IdrisData{Byte} is the description of bytes.
%
Their static size is precisely one byte, and they do not require an
offset to be stored either.

\IdrisData{Prod} gives us the ability to pair two descriptions together.
Its static size and the number of offsets are the respective sums of the
static sizes and numbers of offsets of each subdescription.
%
The description of the left element of the pair will never be in the
rightmost branch of the overall constructors description and so its
index is \IdrisData{False} while the description of the right element
of the pair is in the rightmost branch precisely whenever the whole pair
is; hence the propagation of the \IdrisBound{r} arbitrary value from the
return index into the description of the right component.

Last but not least, \IdrisData{Rec} is a position for a subtree.
We cannot know its size in bytes statically and so we decide to store
an offset unless we are in the rightmost branch of the overall description.
%
Indeed, in the rightmost branch of a constructor we have no reason to
skip over the subterm to access other parts of the stored data. And so we
do not bother recording an offset for it.


\subsection{Constructors}

We represent a constructor as a record packing together
a name for the constructor,
the description of its payload (which is, by virtue of
being used at the toplevel, in rightmost position),
and the values of the \IdrisFunction{static} and
\IdrisFunction{offsets} invariants.
%
The two invariants are stored as implicits fields
because their value is easily reconstructed by \idris{}
using unification and so users do not need
to spell them out explicitly.

\ExecuteMetaData[Serialised/Desc.idr.tex]{constructor}

Note that we used \IdrisData{(::)} as the name of the
constructor for records of type \IdrisType{Constructor}.
This allows us to define constructors by forming an
expression reminiscent of Haskell's type declarations:
\IdrisBound{name} \IdrisData{::} \IdrisBound{type}.

Returning to our running example, this gives us the following encodings for
leaves that do not store anything
and nodes that contain a left branch, a byte, and a right branch.

\ExecuteMetaData[Serialised/Desc.idr.tex]{treeleaf}
\ExecuteMetaData[Serialised/Desc.idr.tex]{treenode}


\subsection{Datatypes}

A datatype description is given by a number of constructors together with
a vector (also known as a length-indexed list) associating a description
to each of these constructors.

\ExecuteMetaData[Serialised/Desc.idr.tex]{data}

We can then encode our running example using the following \IdrisType{Data}
declaration: a binary tree whose node stores bytes is described by the choice
of either a \IdrisFunction{Leaf} or \IdrisFunction{Node}, as defined above.

\ExecuteMetaData[Serialised/Desc.idr.tex]{treedesc}

Now that we have a language that allows us to give a description of our
inductive types, we are going to give these descriptions a meaning as trees.
