\subsection{Limitations and Future Work}

Although our design is already proven to be functional by two implementations
in \idris{} and \agda{} respectively, we can always do better.
%
In this section we are going to see what benefits future work could bring
across the whole project.

\subsubsection{A More Robust Library}\label{sec:limitation-robust}

For sake of ease of presentation we have not dealt with issues necessitating
buffer resizing: in \Cref{sec:serialising},
we defined \IdrisFunction{execSerialising}
by allocating a fixed size buffer and not worrying whether the whole content
would fit.
%
A real library would need to adopt a more robust approach
akin to the one used in the implementation of \idris{}'s own serialisation
code: whenever we are about to write a byte to the buffer, we make sure there
is either enough space left or we grow it.
%
Note that our Agda port does not suffer from this limitation as it
can rely on Haskell's {\usestt\texttt{bytestring}} library and use its
{\usestt\texttt{Builder}} type.

In our library, the data types descriptions currently need to be defined
as values in the host language.
%
This opens up the opportunity for bugs if, say, we write a server in
\idris{} and a client in \agda{} and accidentally use two slightly
different descriptions in the projects.
%
This could be solved at the language level by equipping our dependently typed
languages with dependent type providers like Idris~1
had~\citep{DBLP:conf/icfp/Christiansen13}.
%
This way the format could be loaded at compile time from the same file thus
ensuring all the components are referring to the exact same specification.


\subsubsection{A More Efficient Library}

Looking at the code generated by \idris{}, we notice that our generic programs
are not specialised and partially evaluated even when the types they are working
on are statically known.
%
Refactoring the library to use a continuation-passing-style approach does help
the compiler generate slightly more specialised code but the results are in our
opinion not good enough to justify forcing users to program in this more
cumbersome style.
%
A possible alternative would be to present users with macros rather than
generic programs so that the partial evaluation would be guaranteed to
happen at typechecking time. This however makes the process of defining
the generic programs much more error prone.
%
A more principled approach would be to extend \idris{} with a proper
treatment of staging e.g. by using a two-level type theory as suggested
by Kov{\'{a}}cs~\citep{DBLP:journals/pacmpl/Kovacs22}.

Our serialisation format has been designed to avoid pointer-chasing and
thus ensures entire subtrees can be easily copied by using the raw bytes.
Correspondingly it currently does not support sharing.
%
This could however be a crucial feature for trees with a lot of duplicated
nodes and we would like to allow users to, using the same interface,
easily pick between different serialisation formats so that the library
ends up using the one that suits their application best.
%
To this end, we could take inspiration from Yallop's
definition of preprocessors generating serialisers~\citep{DBLP:conf/ml/Yallop07}.
It maintains an object map containing the already serialised nodes and uses it
to maximally detect sharing and maintain it both when serialising and deserialising.


Our current approach allows us to define a correct-by-construction
\IdrisFunction{sum} operating directly on serialised data but it
does not eliminate the call stack used in the na√Øve functional
implementation.
%
Converting a fold to a tail recursive function in a generic manner
is a well studied problem and the existing
solutions~\citep{DBLP:conf/popl/McBride08,DBLP:conf/icfp/CortinasS18}
should be fairly straightforward, if time-consuming, to port to our setting.

\subsubsection{A More Expressive Universe of Descriptions}

We have used a minimal universe to demonstrate our approach but a practical
application would require the ability to store more than just raw bytes.
An easy extension is to add support for all of the numeric types of
known size that \idris{} offers
(\IdrisType{Bits\{8,16,32,64\}}, \IdrisType{Int\{8,16,32,64\}}),
for \IdrisType{Bool}
as well as a unbounded data such as \IdrisType{Nat}, or \IdrisType{String}
as long as an extra offset is provided for each value.

The storage of values smaller than a byte (here \IdrisType{Bool}) naturally
raises the question of bit packing: why store eight booleans as eight bytes
when they could fit in a single one?
%
\iftoggle{BLIND}{Allais'}{Our} recent work~\citep{DBLP:conf/esop/Allais23}
on the efficient runtime representation of inductive families as values
of \idris{}'s primitive types points us in the direction of a solution.

A natural next candidate is a universe allowing the definition of parametrised
types~\citep{DBLP:conf/icfp/LohM11}: we should be able to implement functions over arbitrary
(\IdrisType{List} \IdrisBound{a}) values stored in a buffer,
provided that we know that \IdrisBound{a} is serialisable.
%
This was already an explicit need in ASN.1~\citep{MANUAL:book/larmouth1999},
reflecting that protocols often leave `holes' where the content of
the protocol's higher layer is to be inserted.

Next, we will want to consider a universe of indexed data:
we can currently natively model algebraic datatypes such as lists or trees,
we can use the host language to compute the description of vectors by induction on their length,
but we cannot model arbitrary type families~\citep{DBLP:journals/fac/Dybjer94}
e.g. correct-by-construction red-black trees.

Last but not least we may want to have a universe of descriptions closed
under least fixpoints~\citep{DBLP:phd/ethos/Morris07}
in order to represent rose trees for instance.

\subsubsection{A More Expressive Library}

Using McBride's generalisation of one hole contexts~\citep{DBLP:conf/popl/McBride08}
we ought to be able to give a more precise type to the combinator
\IdrisFunction{(\#)} used to build serialisation processes.
%
When defining the serialisation of a given subtree, we ought to have access to
pointers to the result of serialising any subtree to the left of it. In particular
this would make building complete binary trees a lot faster by allowing us to rely
on \IdrisFunction{copyData} for duplicating branches rather than running the computation
twice.

Last, but not least we currently do not support in-place updates to
the data stored in a buffer.
This could however be beneficial for functions like \IdrisFunction{map}.
%
It remains to be seen whether we can somehow leverage \idris{}'s
linear quantity annotation to provide users with serialised value that
can be safely updated in place.
%
This would turn our ongoing metaphor involving
Hoare triples~\citep{DBLP:journals/cacm/Hoare69},
heap pointers,
and separation logic~\citep{DBLP:conf/lics/Reynolds02}
into a bona fide shallow embedding.
%
Poulsen, Rouvoet, Tolmach, Krebbers, and Visser's
pioneering work~\citep{DBLP:journals/pacmpl/PoulsenRTKV18,DBLP:phd/basesearch/Rouvoet21}
on definitional interpreters for languages with references
and the use of a shallowly embedded separation logic to
minimise bookkeeping give us a clear set of techniques
to adapt to our setting.
